// =======================================================
// üìÑ File: http-diveLogs.jsw - MERGED VERSION
// Description: Comprehensive backend functions for managing user dive logs.
// Combines simple Next.js integration with advanced search capabilities
// Handles both direct API calls and Wix site integration
// =======================================================

import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { fetch } from 'wix-fetch';
import { ok, badRequest, serverError } from 'wix-http-functions';

// ‚úÖ CONFIGURATION
const COLLECTION_ID = "@deepfreediving/kovaldeepai-app/Import1";
const SEMANTIC_SEARCH_API = "https://kovaldeepai-main.vercel.app/api/pinecone";
const MAX_RESULTS = 100;

// ‚úÖ Response helpers (inline since http-utils.jsw might not exist)
function createResponse(status, data, request) {
    return {
        status,
        body: data,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization'
        }
    };
}

const successResponse = (request, data) => createResponse(200, data, request);
const badRequestResponse = (request, message) => createResponse(400, { error: message, success: false }, request);
const unauthorizedResponse = (request, message) => createResponse(401, { error: message, success: false }, request);
const serverErrorResponse = (request, message) => createResponse(500, { error: message, success: false }, request);
const baseResponse = (status, request) => ({ status, headers: createResponse(status, {}, request).headers });

/**
 * ‚úÖ OPTIONS: Preflight requests
 */
export function options_diveLogs(request) {
    return baseResponse(204, request);
}

/**
 * ‚úÖ POST: Save dive log data 
 * Handles both Next.js API calls and direct submissions
 */
export async function post_diveLogs(request) {
    try {
        console.log('üíæ diveLogs POST function called');
        
        // ‚úÖ USER IDENTIFICATION
        let userId;
        try {
            const currentUser = await wixUsersBackend.currentUser;
            userId = currentUser?.id;
        } catch (authError) {
            console.log("‚ÑπÔ∏è No authenticated user");
        }

        // ‚úÖ PARSE REQUEST BODY
        const body = await parseRequestBody(request);
        
        if (!userId && body.userId) {
            userId = body.userId;
        }

        if (!userId) {
            return unauthorizedResponse(request, "User not identified");
        }

        // Handle both formats: direct diveLog object or nested in body.diveLog
        const diveLogData = body.diveLog || body;
        
        if (!diveLogData || (!diveLogData.discipline && !diveLogData.disciplineType)) {
            console.log('‚ùå Missing dive log data');
            return badRequest({
                body: JSON.stringify({
                    success: false,
                    error: 'Missing dive log data'
                })
            });
        }

        console.log(`üìä Saving dive log for user: ${userId}`);
        console.log(`üìù Dive: ${diveLogData.discipline || diveLogData.disciplineType} at ${diveLogData.location}`);

        // ‚úÖ VALIDATE DIVE LOG DATA
        const validationError = validateDiveLog(diveLogData);
        if (validationError) {
            return badRequestResponse(request, validationError);
        }

        // ‚úÖ PREPARE DIVE LOG ENTRY
        const timestamp = new Date();
        const uniqueKey = diveLogData.id || `dive-${userId}-${timestamp.getTime()}`;

        const diveLogEntry = {
            userId,
            uniqueKey,
            timestamp,
            type: 'dive-log',
            source: 'dive-logs-api',
            
            // Core dive log data - comprehensive mapping
            ...mapDiveLogFields(diveLogData),
            
            // For AI context
            memoryContent: `Dive Log: ${diveLogData.discipline || diveLogData.disciplineType} at ${diveLogData.location}, reached ${diveLogData.reachedDepth}m (target: ${diveLogData.targetDepth}m). ${diveLogData.notes || 'No additional notes.'}`,
            logEntry: `${diveLogData.date}: ${diveLogData.discipline || diveLogData.disciplineType} dive at ${diveLogData.location}`
        };

        // ‚úÖ SAVE TO WIX DATABASE
        let saved;
        try {
            // Check if dive log already exists (prevent duplicates)
            const existing = await wixData.query(COLLECTION_ID)
                .eq("userId", userId)
                .eq("uniqueKey", uniqueKey)
                .find();
                
            if (existing.items.length > 0) {
                // Update existing dive log
                saved = await wixData.update(COLLECTION_ID, {
                    _id: existing.items[0]._id,
                    ...diveLogEntry
                });
                console.log('‚úÖ Updated existing dive log in Wix');
            } else {
                // Create new dive log
                saved = await wixData.insert(COLLECTION_ID, diveLogEntry);
                console.log('‚úÖ Created new dive log in Wix');
            }
        } catch (dbError) {
            console.error('‚ùå Database save error:', dbError);
            return serverErrorResponse(request, "Failed to save dive log to database");
        }

        // ‚úÖ SYNC TO NEXT.JS BACKEND (non-blocking)
        syncDiveLogToBackend(saved).catch(err => {
            console.warn("‚ö†Ô∏è Backend sync failed:", err.message);
        });

        // Return response in both formats for compatibility
        const responseData = {
            success: true,
            message: 'Dive log saved successfully to Wix',
            data: [saved], // Array format for compatibility
            diveLogId: saved._id,
            timestamp: timestamp.toISOString()
        };

        // Use Wix HTTP functions format for Next.js calls, or standard format for others
        if (body.diveLog) {
            // Next.js API call format
            return ok({
                body: JSON.stringify(responseData)
            });
        } else {
            // Standard Wix format
            return successResponse(request, responseData);
        }
        
    } catch (error) {
        console.error('‚ùå diveLogs POST error:', error);
        return serverError({
            body: JSON.stringify({
                success: false,
                error: 'Failed to save dive log',
                details: error.message
            })
        });
    }
}

/**
 * ‚úÖ GET: Retrieve dive logs with enhanced search capabilities
 */
export async function get_diveLogs(request) {
    try {
        // ‚úÖ USER IDENTIFICATION
        let userId = request.query?.userId;
        
        try {
            const currentUser = await wixUsersBackend.currentUser;
            if (currentUser?.id) {
                userId = currentUser.id;
            }
        } catch (authError) {
            console.log("‚ÑπÔ∏è No authenticated user, using query userId");
        }

        if (!userId) {
            return unauthorizedResponse(request, "User not identified. Please provide userId parameter or log in.");
        }

        const { 
            q: searchQuery, 
            limit = 50, 
            skip = 0,
            discipline,
            location,
            minDepth,
            maxDepth,
            dateFrom,
            dateTo,
            sortBy = 'timestamp',
            sortOrder = 'desc'
        } = request.query;

        console.log(`üìä Loading dive logs for user: ${userId}`);
        console.log(`üîç Search query: "${searchQuery}", filters applied: ${!!discipline || !!location || !!minDepth}`);

        let items = [];
        let totalCount = 0;
        let searchType = 'database';

        // ‚úÖ SEMANTIC SEARCH if query provided
        if (searchQuery && searchQuery.trim().length > 2) {
            try {
                const semanticResults = await performSemanticDiveSearch(searchQuery, userId, parseInt(limit));
                if (semanticResults.success) {
                    items = semanticResults.data.filter(item => isDiveLog(item));
                    totalCount = items.length;
                    searchType = 'semantic';
                }
            } catch (semanticError) {
                console.warn("‚ö†Ô∏è Semantic search failed, falling back to database search:", semanticError);
            }
        }

        // ‚úÖ DATABASE SEARCH (if no query or semantic search failed)
        if (!searchQuery || searchType === 'database') {
            const dbResults = await performDiveLogDatabaseSearch(
                userId, searchQuery, parseInt(limit), parseInt(skip), 
                { discipline, location, minDepth, maxDepth, dateFrom, dateTo },
                sortBy, sortOrder
            );
            items = dbResults.items;
            totalCount = dbResults.totalCount;
            searchType = 'database';
        }

        // ‚úÖ ENHANCE ITEMS WITH COMPUTED FIELDS
        const enhancedItems = items.map(item => ({
            ...item,
            searchType,
            // Computed fields
            depthAchieved: item.reachedDepth || item.targetDepth || 0,
            depthProgress: item.reachedDepth && item.targetDepth ? 
                Math.round((item.reachedDepth / item.targetDepth) * 100) : 0,
            hasNotes: !!(item.notes && item.notes.trim()),
            daysSinceLog: item.timestamp ? 
                Math.floor((new Date() - new Date(item.timestamp)) / (1000 * 60 * 60 * 24)) : 0,
            isDiveLog: true
        }));

        return successResponse(request, {
            success: true,
            count: enhancedItems.length,
            totalCount,
            data: enhancedItems,
            searchType,
            query: searchQuery,
            userId,
            pagination: {
                limit: parseInt(limit),
                skip: parseInt(skip),
                hasMore: parseInt(skip) + enhancedItems.length < totalCount
            }
        });
        
    } catch (error) {
        console.error('‚ùå diveLogs GET error:', error);
        return serverErrorResponse(request, "Failed to retrieve dive logs");
    }
}

/**
 * ‚úÖ HELPER FUNCTIONS
 */

/**
 * Parse request body safely
 */
async function parseRequestBody(request) {
    try {
        const bodyText = await request.body.text();
        return JSON.parse(bodyText);
    } catch (parseError) {
        console.warn("‚ö†Ô∏è Failed to parse request body:", parseError);
        return {};
    }
}

/**
 * Validate dive log data
 */
function validateDiveLog(diveLog) {
    if (!diveLog) return "Missing dive log data";
    
    // At minimum, we need either discipline or disciplineType
    if (!diveLog.discipline && !diveLog.disciplineType) {
        return "Missing discipline information";
    }
    
    // Validate numeric fields if present
    const numericFields = ['targetDepth', 'reachedDepth', 'mouthfillDepth', 'issueDepth'];
    for (const field of numericFields) {
        if (diveLog[field] !== undefined && diveLog[field] !== null && diveLog[field] !== '') {
            const num = parseFloat(diveLog[field]);
            if (isNaN(num) || num < 0) {
                return `Invalid ${field}: must be a positive number`;
            }
        }
    }
    
    return null; // No validation errors
}

/**
 * Map dive log fields to database format
 */
function mapDiveLogFields(diveLog) {
    return {
        date: diveLog.date ? new Date(diveLog.date) : new Date(),
        disciplineType: String(diveLog.disciplineType || ''),
        discipline: String(diveLog.discipline || ''),
        location: String(diveLog.location || ''),
        targetDepth: parseFloat(diveLog.targetDepth) || 0,
        reachedDepth: parseFloat(diveLog.reachedDepth) || 0,
        mouthfillDepth: parseFloat(diveLog.mouthfillDepth) || 0,
        issueDepth: parseFloat(diveLog.issueDepth) || 0,
        issueComment: String(diveLog.issueComment || ''),
        durationOrDistance: String(diveLog.durationOrDistance || ''),
        totalDiveTime: String(diveLog.totalDiveTime || ''),
        attemptType: String(diveLog.attemptType || ''),
        exit: String(diveLog.exit || ''),
        surfaceProtocol: String(diveLog.surfaceProtocol || ''),
        squeeze: Boolean(diveLog.squeeze),
        notes: String(diveLog.notes || '')
    };
}

/**
 * Check if an item is a dive log
 */
function isDiveLog(item) {
    return item && (
        item.type === 'dive-log' || 
        item.discipline || 
        item.disciplineType || 
        (item.targetDepth && item.targetDepth > 0) ||
        (item.reachedDepth && item.reachedDepth > 0)
    );
}

/**
 * Perform semantic dive search via Next.js API
 */
async function performSemanticDiveSearch(query, userId, limit = 20) {
    try {
        console.log("üîç Performing semantic dive search via Next.js API");

        const response = await fetch(SEMANTIC_SEARCH_API, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'query',
                query: `dive log ${query}`, // Prefix to focus on dive logs
                topK: limit,
                filter: { 
                    userId: { $eq: userId },
                    type: { $eq: 'user-memory' }
                }
            })
        });

        if (!response.ok) {
            throw new Error(`Semantic search API returned ${response.status}`);
        }

        const data = await response.json();
        
        if (!data.success || !data.matches) {
            throw new Error('Invalid response from semantic search API');
        }

        // Map Pinecone results to dive log format
        const items = data.matches
            .filter(match => isDiveLogMatch(match))
            .map(match => ({
                _id: match.id,
                userId: match.metadata?.userId || userId,
                discipline: match.metadata?.discipline || '',
                location: match.metadata?.location || '',
                targetDepth: match.metadata?.targetDepth || 0,
                reachedDepth: match.metadata?.reachedDepth || 0,
                timestamp: match.metadata?.timestamp || new Date().toISOString(),
                notes: match.metadata?.notes || '',
                score: match.score,
                searchType: 'semantic'
            }));

        return {
            success: true,
            data: items,
            count: items.length
        };

    } catch (error) {
        console.error("‚ùå Semantic dive search error:", error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Check if semantic search match is dive log related
 */
function isDiveLogMatch(match) {
    const metadata = match.metadata || {};
    return metadata.discipline || 
           metadata.disciplineType || 
           metadata.targetDepth || 
           metadata.reachedDepth ||
           (metadata.type && metadata.type.includes('dive'));
}

/**
 * Perform database search for dive logs
 */
async function performDiveLogDatabaseSearch(userId, searchQuery, limit, skip, filters, sortBy, sortOrder) {
    try {
        console.log("üóÑÔ∏è Performing dive log database search");

        let query = wixData.query(COLLECTION_ID)
            .eq("userId", userId);

        // Filter for dive logs (items with depth data or dive log type)
        const diveLogQuery = wixData.query(COLLECTION_ID)
            .eq("userId", userId)
            .or(
                wixData.query(COLLECTION_ID).eq("type", "dive-log"),
                wixData.query(COLLECTION_ID).gt("targetDepth", 0),
                wixData.query(COLLECTION_ID).gt("reachedDepth", 0)
            );

        // Apply filters
        if (filters.discipline) {
            diveLogQuery.contains("discipline", filters.discipline);
        }
        if (filters.location) {
            diveLogQuery.contains("location", filters.location);
        }
        if (filters.minDepth) {
            diveLogQuery.ge("reachedDepth", parseFloat(filters.minDepth));
        }
        if (filters.maxDepth) {
            diveLogQuery.le("reachedDepth", parseFloat(filters.maxDepth));
        }
        if (filters.dateFrom) {
            diveLogQuery.ge("date", new Date(filters.dateFrom));
        }
        if (filters.dateTo) {
            diveLogQuery.le("date", new Date(filters.dateTo));
        }

        // Apply text search if provided
        if (searchQuery && searchQuery.trim()) {
            diveLogQuery.or(
                wixData.query(COLLECTION_ID).contains("discipline", searchQuery),
                wixData.query(COLLECTION_ID).contains("location", searchQuery),
                wixData.query(COLLECTION_ID).contains("notes", searchQuery)
            );
        }

        // Apply sorting
        if (sortOrder === 'desc') {
            diveLogQuery.descending(sortBy);
        } else {
            diveLogQuery.ascending(sortBy);
        }

        // Apply pagination
        diveLogQuery.skip(skip).limit(Math.min(limit, MAX_RESULTS));

        const result = await diveLogQuery.find();

        return {
            items: result.items || [],
            totalCount: result.totalCount || result.items?.length || 0
        };

    } catch (error) {
        console.error("‚ùå Database search error:", error);
        return {
            items: [],
            totalCount: 0
        };
    }
}

/**
 * Sync dive log to Next.js backend (non-blocking)
 */
async function syncDiveLogToBackend(diveLogData) {
    if (!diveLogData) return;

    try {
        const payload = {
            userId: diveLogData.userId,
            diveLog: {
                id: diveLogData.uniqueKey,
                discipline: diveLogData.discipline,
                location: diveLogData.location,
                targetDepth: diveLogData.targetDepth,
                reachedDepth: diveLogData.reachedDepth,
                notes: diveLogData.notes,
                date: diveLogData.date
            }
        };

        // Call Next.js backend to handle embeddings and analysis
        const response = await fetch('https://kovaldeepai-main.vercel.app/api/userMemory/sync', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            console.warn(`‚ö†Ô∏è Backend sync failed: ${response.status}`);
        } else {
            console.log('‚úÖ Successfully synced dive log to Next.js backend');
        }

    } catch (error) {
        console.warn("‚ö†Ô∏è Backend sync error:", error.message);
        // Don't throw - this is non-critical
    }
}
