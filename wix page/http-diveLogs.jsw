// üî• HTTP-DIVELOGS-MASTER.JSW - ALL-IN-ONE DIVE LOGS API
// Consolidates: http-diveLogs + http-diveLogs-expert (empty)
// Version: 4.0.0 - Master Consolidated Edition
// Date: August 8, 2025

import { ok, badRequest, serverError, notFound } from 'wix-http-functions';
import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { fetch } from 'wix-fetch';
import { WixUtilsMaster, MASTER_CONFIG } from 'backend/wix-utils-master.jsw';

// üéØ MASTER CONFIGURATION
const DIVELOGS_CONFIG = {
  API_VERSIONS: {
    BASIC: 'basic',           // Simple CRUD operations
    EXPERT: 'expert',         // Advanced features + semantic search
    OPTIMIZED: 'optimized'    // Index-aware + performance tracking
  },
  
  COLLECTION_NAME: '@deepfreediving/kovaldeepai-app/Import1',
  SEMANTIC_SEARCH_API: 'https://kovaldeepai-main.vercel.app/api/pinecone',
  
  VALIDATION: {
    REQUIRED_FIELDS: ['userId', 'diveDate'],
    MAX_DEPTH: 400,           // Maximum depth in meters
    MAX_TIME: 1800,           // Maximum time in seconds (30 minutes)
    VALID_DISCIPLINES: ['STA', 'DYN', 'DNF', 'CWT', 'CNF', 'FIM', 'VWT', 'NLT']
  },
  
  PERFORMANCE: {
    SLOW_QUERY_THRESHOLD: 2500,
    ENABLE_ANALYTICS: true,
    SEMANTIC_SEARCH_TIMEOUT: 5000
  }
};

// üî• PERFORMANCE METRICS (Expert/Optimized levels)
let diveLogsMetrics = {
  saves: 0,
  queries: 0,
  semanticSearches: 0,
  totalDuration: 0,
  errors: 0,
  slowQueries: 0,
  byVersion: {
    basic: { requests: 0, duration: 0 },
    expert: { requests: 0, duration: 0 },
    optimized: { requests: 0, duration: 0 }
  }
};

// üî• DATA VALIDATION SCHEMA
const DIVELOG_SCHEMA = {
  userId: { type: 'string', required: true },
  diveDate: { type: 'string', required: true },
  discipline: { type: 'string', enum: DIVELOGS_CONFIG.VALIDATION.VALID_DISCIPLINES },
  reachedDepth: { type: 'number', min: 0, max: DIVELOGS_CONFIG.VALIDATION.MAX_DEPTH },
  diveTime: { type: 'number', min: 0, max: DIVELOGS_CONFIG.VALIDATION.MAX_TIME },
  notes: { type: 'string', maxLength: 2000 },
  location: { type: 'string', maxLength: 200 },
  waterTemp: { type: 'number' },
  visibility: { type: 'string' },
  equipment: { type: 'object' }
};

// üî• VALIDATION ENGINE
function validateDiveLog(data, version = 'basic') {
  const errors = [];
  
  // Required fields check
  DIVELOGS_CONFIG.VALIDATION.REQUIRED_FIELDS.forEach(field => {
    if (!data[field]) {
      errors.push(`Missing required field: ${field}`);
    }
  });
  
  // Depth validation
  if (data.reachedDepth && (data.reachedDepth < 0 || data.reachedDepth > DIVELOGS_CONFIG.VALIDATION.MAX_DEPTH)) {
    errors.push(`Invalid depth: ${data.reachedDepth}m (max: ${DIVELOGS_CONFIG.VALIDATION.MAX_DEPTH}m)`);
  }
  
  // Time validation
  if (data.diveTime && (data.diveTime < 0 || data.diveTime > DIVELOGS_CONFIG.VALIDATION.MAX_TIME)) {
    errors.push(`Invalid time: ${data.diveTime}s (max: ${DIVELOGS_CONFIG.VALIDATION.MAX_TIME}s)`);
  }
  
  // Discipline validation
  if (data.discipline && !DIVELOGS_CONFIG.VALIDATION.VALID_DISCIPLINES.includes(data.discipline)) {
    errors.push(`Invalid discipline: ${data.discipline}`);
  }
  
  // Expert/Optimized level validations
  if (version !== 'basic') {
    if (data.diveDate && !isValidDate(data.diveDate)) {
      errors.push('Invalid date format');
    }
  }
  
  return errors;
}

// üî• UTILITY FUNCTIONS
function isValidDate(dateString) {
  const date = new Date(dateString);
  return date instanceof Date && !isNaN(date);
}

function createResponse(status, data, request) {
  return {
    status,
    body: data,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-API-Version'
    }
  };
}

function getApiVersion(request) {
  return request.headers['x-api-version'] || 
         request.query.version || 
         DIVELOGS_CONFIG.API_VERSIONS.EXPERT; // Default to expert
}

// üî• PERFORMANCE TRACKING
function trackMetrics(version, operation, duration, error = false) {
  diveLogsMetrics.byVersion[version].requests++;
  diveLogsMetrics.byVersion[version].duration += duration;
  diveLogsMetrics.totalDuration += duration;
  
  switch(operation) {
    case 'save':
      diveLogsMetrics.saves++;
      break;
    case 'query':
      diveLogsMetrics.queries++;
      break;
    case 'semanticSearch':
      diveLogsMetrics.semanticSearches++;
      break;
  }
  
  if (error) diveLogsMetrics.errors++;
  if (duration > DIVELOGS_CONFIG.PERFORMANCE.SLOW_QUERY_THRESHOLD) {
    diveLogsMetrics.slowQueries++;
    console.log(`üêå Slow dive logs query: ${duration}ms`);
  }
}

// üî• MAIN API ENDPOINTS

/**
 * OPTIONS: Preflight requests
 */
export function options_diveLogs(request) {
  return createResponse(204, {}, request);
}

/**
 * POST: Save dive log data 
 * Supports all API versions with appropriate feature sets
 */
export async function post_diveLogs(request) {
  const startTime = Date.now();
  const version = getApiVersion(request);
  
  try {
    const requestData = await request.body.json();
    
    // Validation
    const validationErrors = validateDiveLog(requestData, version);
    if (validationErrors.length > 0) {
      trackMetrics(version, 'save', Date.now() - startTime, true);
      return createResponse(400, {
        error: 'Validation failed',
        details: validationErrors,
        success: false
      }, request);
    }
    
    // Add metadata based on version
    const diveLogData = {
      ...requestData,
      _createdDate: new Date(),
      _updatedDate: new Date(),
      apiVersion: version
    };
    
    // Expert/Optimized: Add additional tracking
    if (version !== 'basic') {
      diveLogData.submissionTimestamp = new Date().toISOString();
      diveLogData.dataSource = 'wix-api';
      
      // Optimized: Add performance hints
      if (version === 'optimized') {
        diveLogData.indexHints = {
          primaryQuery: ['userId', 'diveDate'],
          searchable: ['discipline', 'location', 'notes']
        };
      }
    }
    
    // Save to Wix Data
    const result = await wixData.save(DIVELOGS_CONFIG.COLLECTION_NAME, diveLogData);
    
    const duration = Date.now() - startTime;
    trackMetrics(version, 'save', duration);
    
    return createResponse(200, {
      success: true,
      data: result,
      _id: result._id,
      version: version,
      ...(version !== 'basic' && { 
        performance: { 
          duration: `${duration}ms`,
          version: version
        }
      })
    }, request);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics(version, 'save', duration, true);
    
    console.error('‚ùå Error saving dive log:', error);
    return createResponse(500, {
      error: 'Failed to save dive log',
      details: error.message,
      success: false,
      version: version
    }, request);
  }
}

/**
 * GET: Retrieve dive logs with advanced filtering
 * Supports semantic search in expert/optimized modes
 */
export async function get_diveLogs(request) {
  const startTime = Date.now();
  const version = getApiVersion(request);
  
  try {
    const { userId, limit = 50, search, discipline, dateFrom, dateTo, semantic } = request.query;
    
    if (!userId) {
      trackMetrics(version, 'query', Date.now() - startTime, true);
      return createResponse(400, {
        error: 'userId is required',
        success: false
      }, request);
    }
    
    // Build query based on version
    let query = wixData.query(DIVELOGS_CONFIG.COLLECTION_NAME)
      .eq('userId', userId)
      .limit(Math.min(parseInt(limit), 100)); // Cap at 100
    
    // Add filters
    if (discipline) {
      query = query.eq('discipline', discipline);
    }
    
    if (dateFrom) {
      query = query.ge('diveDate', dateFrom);
    }
    
    if (dateTo) {
      query = query.le('diveDate', dateTo);
    }
    
    // Basic text search
    if (search && !semantic) {
      query = query.contains('notes', search);
    }
    
    // Expert/Optimized: Enhanced ordering
    if (version !== 'basic') {
      query = query.descending('diveDate');
    }
    
    // Execute query
    const results = await query.find();
    
    // Expert/Optimized: Semantic search capability
    let semanticResults = null;
    if ((version === 'expert' || version === 'optimized') && semantic && search) {
      try {
        const semanticResponse = await fetch(DIVELOGS_CONFIG.SEMANTIC_SEARCH_API, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            query: search,
            userId: userId,
            type: 'diveLogs',
            limit: 10
          })
        });
        
        if (semanticResponse.ok) {
          semanticResults = await semanticResponse.json();
          trackMetrics(version, 'semanticSearch', Date.now() - startTime);
        }
      } catch (semanticError) {
        console.warn('‚ö†Ô∏è Semantic search failed:', semanticError.message);
      }
    }
    
    const duration = Date.now() - startTime;
    trackMetrics(version, 'query', duration);
    
    const response = {
      success: true,
      data: results.items,
      totalCount: results.totalCount,
      hasNext: results.hasNext(),
      version: version
    };
    
    // Expert/Optimized: Add enhanced data
    if (version !== 'basic') {
      response.performance = {
        duration: `${duration}ms`,
        queryOptimization: results.items.length > 0 ? 'indexed' : 'scan'
      };
      
      if (semanticResults) {
        response.semanticMatches = semanticResults;
      }
    }
    
    return createResponse(200, response, request);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics(version, 'query', duration, true);
    
    console.error('‚ùå Error retrieving dive logs:', error);
    return createResponse(500, {
      error: 'Failed to retrieve dive logs',
      details: error.message,
      success: false,
      version: version
    }, request);
  }
}

/**
 * PUT: Update existing dive log
 */
export async function put_diveLogs(request) {
  const startTime = Date.now();
  const version = getApiVersion(request);
  
  try {
    const { diveLogId } = request.query;
    const updateData = await request.body.json();
    
    if (!diveLogId) {
      trackMetrics(version, 'save', Date.now() - startTime, true);
      return createResponse(400, {
        error: 'diveLogId is required',
        success: false
      }, request);
    }
    
    // Validation
    const validationErrors = validateDiveLog(updateData, version);
    if (validationErrors.length > 0) {
      trackMetrics(version, 'save', Date.now() - startTime, true);
      return createResponse(400, {
        error: 'Validation failed',
        details: validationErrors,
        success: false
      }, request);
    }
    
    // Prepare update
    const updatePayload = {
      _id: diveLogId,
      ...updateData,
      _updatedDate: new Date(),
      lastModifiedVersion: version
    };
    
    const result = await wixData.update(DIVELOGS_CONFIG.COLLECTION_NAME, updatePayload);
    
    const duration = Date.now() - startTime;
    trackMetrics(version, 'save', duration);
    
    return createResponse(200, {
      success: true,
      data: result,
      version: version,
      ...(version !== 'basic' && { 
        performance: { duration: `${duration}ms` }
      })
    }, request);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics(version, 'save', duration, true);
    
    console.error('‚ùå Error updating dive log:', error);
    return createResponse(500, {
      error: 'Failed to update dive log',
      details: error.message,
      success: false,
      version: version
    }, request);
  }
}

/**
 * DELETE: Remove dive log
 */
export async function delete_diveLogs(request) {
  const startTime = Date.now();
  const version = getApiVersion(request);
  
  try {
    const { diveLogId } = request.query;
    
    if (!diveLogId) {
      trackMetrics(version, 'query', Date.now() - startTime, true);
      return createResponse(400, {
        error: 'diveLogId is required',
        success: false
      }, request);
    }
    
    await wixData.remove(DIVELOGS_CONFIG.COLLECTION_NAME, diveLogId);
    
    const duration = Date.now() - startTime;
    trackMetrics(version, 'query', duration);
    
    return createResponse(200, {
      success: true,
      message: 'Dive log deleted successfully',
      version: version,
      ...(version !== 'basic' && { 
        performance: { duration: `${duration}ms` }
      })
    }, request);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics(version, 'query', duration, true);
    
    console.error('‚ùå Error deleting dive log:', error);
    return createResponse(500, {
      error: 'Failed to delete dive log',
      details: error.message,
      success: false,
      version: version
    }, request);
  }
}

/**
 * Expert/Optimized: Get performance metrics
 */
export async function get_diveLogsMetrics(request) {
  const version = getApiVersion(request);
  
  if (version === 'basic') {
    return createResponse(403, {
      error: 'Metrics available in expert/optimized versions only',
      success: false
    }, request);
  }
  
  return createResponse(200, {
    success: true,
    metrics: diveLogsMetrics,
    config: DIVELOGS_CONFIG,
    version: version
  }, request);
}

// üî• BACKWARD COMPATIBILITY LAYER
// Legacy function names for existing integrations
export const saveDiveLog = post_diveLogs;
export const getDiveLogs = get_diveLogs;
export const updateDiveLog = put_diveLogs;
export const deleteDiveLog = delete_diveLogs;

console.log("üî• Dive Logs Master API initialized - All versions supported");
