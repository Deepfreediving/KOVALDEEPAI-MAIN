// ===== ðŸ“„ http-userMemory.jsw - CONSOLIDATED MEMORY MANAGEMENT =====
// Unified endpoint for all user memory operations (CRUD + Search)
// Consolidates: http-getUserMemory.jsw, http-saveToUserMemory.jsw, http-loadMemories.jsw

import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { fetch } from 'wix-fetch';
import { 
    successResponse, 
    badRequestResponse, 
    unauthorizedResponse, 
    serverErrorResponse, 
    baseResponse 
} from './http-utils.jsw';
import { 
    COLLECTIONS, 
    API_ENDPOINTS, 
    LIMITS, 
    ERROR_MESSAGES,
    MEMORY_TYPES 
} from 'backend/config/constants.jsw';

/**
 * âœ… OPTIONS: Preflight requests
 */
export function options_userMemory(request) {
    return baseResponse(204, request);
}

/**
 * âœ… GET: Retrieve user memories with optional filtering and search
 * Query parameters:
 * - userId (required): User ID to filter by
 * - limit (optional): Max results (default: 50)
 * - type (optional): Memory type filter
 * - search (optional): Semantic search query
 */
export async function get_userMemory(request) {
    try {
        const url = new URL(request.url);
        const userId = url.searchParams.get('userId');
        const limit = parseInt(url.searchParams.get('limit')) || 50;
        const type = url.searchParams.get('type');
        const searchQuery = url.searchParams.get('search');

        if (!userId) {
            return badRequestResponse(request, ERROR_MESSAGES.MISSING_USER_ID);
        }

        console.log(`ðŸ“Š Loading memories for user: ${userId}, limit: ${limit}, type: ${type}, search: ${searchQuery}`);

        let query = wixData.query(COLLECTIONS.USER_MEMORY)
            .eq("userId", userId)
            .descending("timestamp")
            .limit(Math.min(limit, LIMITS.MAX_RESULTS));

        // Apply type filter if specified
        if (type && Object.values(MEMORY_TYPES).includes(type)) {
            query = query.eq("type", type);
        }

        const result = await query.find();
        let memories = result.items || [];

        // Apply semantic search if requested
        if (searchQuery && memories.length > 0) {
            try {
                memories = await performSemanticSearch(memories, searchQuery, userId);
            } catch (searchError) {
                console.warn('âš ï¸ Semantic search failed, returning filtered results:', searchError);
            }
        }

        // Transform data to consistent format
        const transformedMemories = memories.map(transformMemoryItem);

        console.log(`âœ… Retrieved ${transformedMemories.length} memories for user ${userId}`);

        return successResponse(request, {
            data: transformedMemories,
            totalCount: result.totalCount || transformedMemories.length,
            userId,
            filters: { type, searchQuery, limit }
        });

    } catch (error) {
        console.error('âŒ Error retrieving user memories:', error);
        return serverErrorResponse(request, ERROR_MESSAGES.DATABASE_ERROR);
    }
}

/**
 * âœ… POST: Create new memory entry
 * Body should contain:
 * - userId (required)
 * - type (required): Memory type
 * - content/memoryContent: Main content
 * - Additional fields based on type
 */
export async function post_userMemory(request) {
    try {
        const body = await request.body.json();
        const { 
            userId, 
            type = MEMORY_TYPES.SYSTEM_NOTE,
            memoryContent,
            content,
            ...additionalData 
        } = body;

        if (!userId) {
            return badRequestResponse(request, ERROR_MESSAGES.MISSING_USER_ID);
        }

        if (!memoryContent && !content) {
            return badRequestResponse(request, 'Memory content is required');
        }

        console.log(`ðŸ’¾ Saving memory for user: ${userId}, type: ${type}`);

        // Prepare memory entry
        const memoryEntry = {
            userId,
            type,
            memoryContent: memoryContent || content,
            timestamp: new Date().toISOString(),
            source: 'wix-api',
            ...additionalData
        };

        // Save to database
        const savedItem = await wixData.insert(COLLECTIONS.USER_MEMORY, memoryEntry);

        console.log(`âœ… Memory saved successfully: ${savedItem._id}`);

        return successResponse(request, {
            id: savedItem._id,
            data: transformMemoryItem(savedItem),
            message: 'Memory saved successfully'
        });

    } catch (error) {
        console.error('âŒ Error saving memory:', error);
        return serverErrorResponse(request, ERROR_MESSAGES.DATABASE_ERROR);
    }
}

/**
 * âœ… PUT: Update existing memory entry
 */
export async function put_userMemory(request) {
    try {
        const url = new URL(request.url);
        const memoryId = url.searchParams.get('id');
        const body = await request.body.json();

        if (!memoryId) {
            return badRequestResponse(request, 'Memory ID is required');
        }

        console.log(`ðŸ”„ Updating memory: ${memoryId}`);

        // Remove system fields that shouldn't be updated
        const { _id, _createdDate, _updatedDate, ...updateData } = body;
        updateData.timestamp = new Date().toISOString();

        const updatedItem = await wixData.update(COLLECTIONS.USER_MEMORY, memoryId, updateData);

        return successResponse(request, {
            id: updatedItem._id,
            data: transformMemoryItem(updatedItem),
            message: 'Memory updated successfully'
        });

    } catch (error) {
        console.error('âŒ Error updating memory:', error);
        return serverErrorResponse(request, ERROR_MESSAGES.DATABASE_ERROR);
    }
}

/**
 * âœ… DELETE: Remove memory entry
 */
export async function delete_userMemory(request) {
    try {
        const url = new URL(request.url);
        const memoryId = url.searchParams.get('id');

        if (!memoryId) {
            return badRequestResponse(request, 'Memory ID is required');
        }

        console.log(`ðŸ—‘ï¸ Deleting memory: ${memoryId}`);

        await wixData.remove(COLLECTIONS.USER_MEMORY, memoryId);

        return successResponse(request, {
            id: memoryId,
            message: 'Memory deleted successfully'
        });

    } catch (error) {
        console.error('âŒ Error deleting memory:', error);
        return serverErrorResponse(request, ERROR_MESSAGES.DATABASE_ERROR);
    }
}

/**
 * âœ… Helper: Transform memory item to consistent format
 */
function transformMemoryItem(item) {
    return {
        id: item._id,
        userId: item.userId,
        type: item.type || MEMORY_TYPES.SYSTEM_NOTE,
        timestamp: item.timestamp || item._createdDate,
        source: item.source || 'wix-collections',
        
        // Content fields
        memoryContent: item.memoryContent || item.content,
        logEntry: item.logEntry,
        sessionName: item.sessionName,
        
        // Dive log specific fields
        date: item.date,
        disciplineType: item.disciplineType,
        discipline: item.discipline,
        location: item.location,
        targetDepth: item.targetDepth,
        reachedDepth: item.reachedDepth,
        mouthfillDepth: item.mouthfillDepth,
        issueDepth: item.issueDepth,
        issueComment: item.issueComment,
        durationOrDistance: item.durationOrDistance,
        totalDiveTime: item.totalDiveTime,
        attemptType: item.attemptType,
        exit: item.exit,
        surfaceProtocol: item.surfaceProtocol,
        notes: item.notes,
        
        // Coaching fields
        coachingReport: item.coachingReport,
        
        // Metadata
        metadata: item.metadata || {}
    };
}

/**
 * âœ… Helper: Perform semantic search on memories
 */
async function performSemanticSearch(memories, searchQuery, userId) {
    try {
        console.log(`ðŸ” Performing semantic search for: "${searchQuery}"`);
        
        const searchPayload = {
            query: searchQuery,
            userId,
            limit: LIMITS.MAX_SEARCH_RESULTS
        };

        const response = await fetch(API_ENDPOINTS.SEMANTIC_SEARCH, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(searchPayload)
        });

        if (!response.ok) {
            throw new Error(`Semantic search failed: ${response.status}`);
        }

        const searchResults = await response.json();
        
        // Filter memories based on search results
        if (searchResults.matches && searchResults.matches.length > 0) {
            const relevantIds = searchResults.matches.map(match => match.id);
            return memories.filter(memory => 
                relevantIds.includes(memory._id) ||
                memory.memoryContent?.toLowerCase().includes(searchQuery.toLowerCase()) ||
                memory.logEntry?.toLowerCase().includes(searchQuery.toLowerCase())
            );
        }

        return memories;
        
    } catch (error) {
        console.warn('âš ï¸ Semantic search error:', error);
        // Fallback to simple text search
        return memories.filter(memory => 
            memory.memoryContent?.toLowerCase().includes(searchQuery.toLowerCase()) ||
            memory.logEntry?.toLowerCase().includes(searchQuery.toLowerCase()) ||
            memory.notes?.toLowerCase().includes(searchQuery.toLowerCase())
        );
    }
}
