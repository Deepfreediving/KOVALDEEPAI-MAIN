// 🔥 HTTP-USERMEMORY.JSW - ALL-IN-ONE USER MEMORY API
// Consolidates: http-userMemory + http-userMemory-optimized + http-userMemory-expert
// Version: 4.0.0 - Master Consolidated Edition
// Date: August 8, 2025

import { ok, badRequest, serverError, notFound } from 'wix-http-functions';
import wixData from 'wix-data';
import { WixUtilsMaster, MASTER_CONFIG } from 'backend/wix-utils.jsw';

// 🎯 MASTER CONFIGURATION
const MEMORY_CONFIG = {
  API_VERSIONS: {
    BASIC: 'basic',           // Simple CRUD operations
    EXPERT: 'expert',         // Advanced features + monitoring
    OPTIMIZED: 'optimized'    // Index-aware + performance tracking
  },
  
  COLLECTION_NAME: '@deepfreediving/kovaldeepai-app/Import1',
  
  VALIDATION: {
    REQUIRED_FIELDS: ['userId', 'memoryContent'],
    MAX_CONTENT_LENGTH: 10000,
    MAX_BATCH_SIZE: 50
  },
  
  PERFORMANCE: {
    SLOW_QUERY_THRESHOLD: 2000,
    ENABLE_ANALYTICS: true,
    TRACK_METRICS: true
  }
};

// 🔥 PERFORMANCE METRICS (Expert/Optimized levels)
let memoryMetrics = {
  reads: 0,
  writes: 0,
  totalDuration: 0,
  errors: 0,
  slowQueries: 0,
  byVersion: {
    basic: { requests: 0, duration: 0 },
    expert: { requests: 0, duration: 0 },
    optimized: { requests: 0, duration: 0 }
  }
};

// 🔥 DATA VALIDATION SCHEMA
const MEMORY_SCHEMA = {
  userId: { type: 'string', required: true },
  memoryContent: { type: 'string', required: true, maxLength: MEMORY_CONFIG.VALIDATION.MAX_CONTENT_LENGTH },
  logEntry: { type: 'string', required: false },
  sessionName: { type: 'string', required: false },
  type: { type: 'string', required: false, default: 'memory' },
  metadata: { type: 'object', required: false }
};

/**
 * 🚀 MASTER USER MEMORY HTTP FUNCTION
 * Handles all operations with version-based optimization levels
 */
export async function post_userMemory(request) {
  const startTime = Date.now();
  
  try {
    // Detect API version from headers or body
    const apiVersion = request.headers['x-api-version'] || 
                      request.body?.apiVersion || 
                      MEMORY_CONFIG.API_VERSIONS.EXPERT;
    
    // Route to appropriate implementation
    let result;
    switch (apiVersion) {
      case MEMORY_CONFIG.API_VERSIONS.BASIC:
        result = await handleBasicRequest(request);
        break;
      case MEMORY_CONFIG.API_VERSIONS.EXPERT:
        result = await handleExpertRequest(request);
        break;
      case MEMORY_CONFIG.API_VERSIONS.OPTIMIZED:
        result = await handleOptimizedRequest(request);
        break;
      default:
        result = await handleExpertRequest(request); // Default to expert
    }
    
    // Track performance metrics
    const duration = Date.now() - startTime;
    if (MEMORY_CONFIG.PERFORMANCE.TRACK_METRICS) {
      updateMetrics(apiVersion, duration, 'success');
    }
    
    return result;
    
  } catch (error) {
    const duration = Date.now() - startTime;
    const apiVersion = request.headers['x-api-version'] || MEMORY_CONFIG.API_VERSIONS.EXPERT;
    
    if (MEMORY_CONFIG.PERFORMANCE.TRACK_METRICS) {
      updateMetrics(apiVersion, duration, 'error');
    }
    
    console.error('❌ User Memory API Error:', {
      error: error.message,
      apiVersion,
      duration,
      path: request.path,
      method: request.method
    });
    
    return serverError({
      error: 'Internal server error',
      message: error.message,
      apiVersion,
      duration
    });
  }
}

/**
 * 📍 BASIC IMPLEMENTATION - Simple CRUD operations
 */
async function handleBasicRequest(request) {
  const { method, body } = request;
  
  switch (method) {
    case 'GET':
      return await getMemoriesBasic(request);
    case 'POST':
      return await saveMemoryBasic(body);
    case 'PUT':
      return await updateMemoryBasic(body);
    case 'DELETE':
      return await deleteMemoryBasic(request);
    default:
      return badRequest({ error: 'Method not supported', method });
  }
}

/**
 * ⭐ EXPERT IMPLEMENTATION - Advanced features + monitoring
 */
async function handleExpertRequest(request) {
  const { method, body, query } = request;
  
  switch (method) {
    case 'GET':
      return await getMemoriesExpert(query);
    case 'POST':
      return await saveMemoryExpert(body);
    case 'PUT':
      return await updateMemoryExpert(body);
    case 'DELETE':
      return await deleteMemoryExpert(query);
    case 'PATCH':
      return await bulkOperationExpert(body);
    default:
      return badRequest({ error: 'Method not supported', method });
  }
}

/**
 * 🔥 OPTIMIZED IMPLEMENTATION - Index-aware + performance tracking
 */
async function handleOptimizedRequest(request) {
  const { method, body, query } = request;
  
  switch (method) {
    case 'GET':
      return await getMemoriesOptimized(query);
    case 'POST':
      return await saveMemoryOptimized(body);
    case 'PUT':
      return await updateMemoryOptimized(body);
    case 'DELETE':
      return await deleteMemoryOptimized(query);
    case 'PATCH':
      return await bulkOperationOptimized(body);
    default:
      return badRequest({ error: 'Method not supported', method });
  }
}

// ===== 📍 BASIC LEVEL OPERATIONS =====

async function getMemoriesBasic(request) {
  const { userId, limit = 25, skip = 0 } = request.query;
  
  if (!userId) {
    return badRequest({ error: 'userId is required' });
  }
  
  try {
    const result = await wixData.query(MEMORY_CONFIG.COLLECTION_NAME)
      .eq('userId', userId)
      .eq('type', 'memory')
      .descending('_createdDate')
      .limit(Number(limit))
      .skip(Number(skip))
      .find();
    
    return ok({
      success: true,
      data: result.items,
      totalCount: result.totalCount,
      apiVersion: 'basic'
    });
  } catch (error) {
    console.error('Basic get memories error:', error);
    return serverError({ error: 'Failed to retrieve memories' });
  }
}

async function saveMemoryBasic(body) {
  const validation = validateMemoryData(body);
  if (!validation.isValid) {
    return badRequest({ error: 'Validation failed', details: validation.errors });
  }
  
  try {
    const memoryData = {
      ...body,
      type: 'memory',
      timestamp: new Date()
    };
    
    const result = await wixData.insert(MEMORY_CONFIG.COLLECTION_NAME, memoryData);
    
    return ok({
      success: true,
      data: result,
      apiVersion: 'basic'
    });
  } catch (error) {
    console.error('Basic save memory error:', error);
    return serverError({ error: 'Failed to save memory' });
  }
}

async function updateMemoryBasic(body) {
  const { _id, ...updateData } = body;
  
  if (!_id) {
    return badRequest({ error: '_id is required for update' });
  }
  
  try {
    const result = await wixData.update(MEMORY_CONFIG.COLLECTION_NAME, {
      _id,
      ...updateData,
      _updatedDate: new Date()
    });
    
    return ok({
      success: true,
      data: result,
      apiVersion: 'basic'
    });
  } catch (error) {
    console.error('Basic update memory error:', error);
    return serverError({ error: 'Failed to update memory' });
  }
}

async function deleteMemoryBasic(request) {
  const { _id } = request.query;
  
  if (!_id) {
    return badRequest({ error: '_id is required for delete' });
  }
  
  try {
    await wixData.remove(MEMORY_CONFIG.COLLECTION_NAME, _id);
    
    return ok({
      success: true,
      message: 'Memory deleted successfully',
      apiVersion: 'basic'
    });
  } catch (error) {
    console.error('Basic delete memory error:', error);
    return serverError({ error: 'Failed to delete memory' });
  }
}

// ===== ⭐ EXPERT LEVEL OPERATIONS =====

async function getMemoriesExpert(query) {
  const { userId, type = 'memory', limit = 25, skip = 0, search = null } = query;
  
  if (!userId) {
    return badRequest({ error: 'userId is required' });
  }
  
  try {
    const builder = new WixUtilsMaster(MEMORY_CONFIG.COLLECTION_NAME, 'expert')
      .forUser(userId)
      .ofType(type);
    
    if (search) {
      builder.searchContent(search);
    }
    
    const result = await builder
      .sortBy('_createdDate', 'desc')
      .paginate(Number(limit), Number(skip))
      .execute();
    
    return ok({
      success: true,
      data: result.items,
      totalCount: result.totalCount,
      analytics: result._indexAnalysis,
      apiVersion: 'expert'
    });
  } catch (error) {
    return await resilientQuery(() => getMemoriesBasic({ query }), error);
  }
}

async function saveMemoryExpert(body) {
  const validation = validateMemoryData(body, 'expert');
  if (!validation.isValid) {
    return badRequest({ error: 'Validation failed', details: validation.errors });
  }
  
  try {
    const memoryData = {
      ...body,
      type: body.type || 'memory',
      timestamp: new Date(),
      metadata: {
        ...body.metadata,
        apiVersion: 'expert',
        createdAt: new Date().toISOString()
      }
    };
    
    const result = await wixData.insert(MEMORY_CONFIG.COLLECTION_NAME, memoryData);
    
    return ok({
      success: true,
      data: result,
      apiVersion: 'expert'
    });
  } catch (error) {
    console.error('Expert save memory error:', error);
    return await resilientQuery(() => saveMemoryBasic(body), error);
  }
}

async function updateMemoryExpert(body) {
  const { _id, ...updateData } = body;
  
  if (!_id) {
    return badRequest({ error: '_id is required for update' });
  }
  
  try {
    // First check if item exists
    const existing = await wixData.get(MEMORY_CONFIG.COLLECTION_NAME, _id);
    if (!existing) {
      return notFound({ error: 'Memory not found', _id });
    }
    
    const result = await wixData.update(MEMORY_CONFIG.COLLECTION_NAME, {
      _id,
      ...updateData,
      _updatedDate: new Date(),
      metadata: {
        ...existing.metadata,
        ...updateData.metadata,
        lastUpdated: new Date().toISOString(),
        apiVersion: 'expert'
      }
    });
    
    return ok({
      success: true,
      data: result,
      apiVersion: 'expert'
    });
  } catch (error) {
    console.error('Expert update memory error:', error);
    return await resilientQuery(() => updateMemoryBasic(body), error);
  }
}

async function deleteMemoryExpert(query) {
  const { _id } = query;
  
  if (!_id) {
    return badRequest({ error: '_id is required for delete' });
  }
  
  try {
    // Check if item exists before deletion
    const existing = await wixData.get(MEMORY_CONFIG.COLLECTION_NAME, _id);
    if (!existing) {
      return notFound({ error: 'Memory not found', _id });
    }
    
    await wixData.remove(MEMORY_CONFIG.COLLECTION_NAME, _id);
    
    return ok({
      success: true,
      message: 'Memory deleted successfully',
      deletedId: _id,
      apiVersion: 'expert'
    });
  } catch (error) {
    console.error('Expert delete memory error:', error);
    return await resilientQuery(() => deleteMemoryBasic({ query }), error);
  }
}

async function bulkOperationExpert(body) {
  const { operation, items } = body;
  
  if (!operation || !Array.isArray(items)) {
    return badRequest({ error: 'operation and items array are required' });
  }
  
  if (items.length > MEMORY_CONFIG.VALIDATION.MAX_BATCH_SIZE) {
    return badRequest({ 
      error: `Batch size exceeds maximum of ${MEMORY_CONFIG.VALIDATION.MAX_BATCH_SIZE}` 
    });
  }
  
  try {
    let result;
    switch (operation) {
      case 'insert':
        result = await wixData.bulkInsert(MEMORY_CONFIG.COLLECTION_NAME, items);
        break;
      case 'update':
        result = await wixData.bulkUpdate(MEMORY_CONFIG.COLLECTION_NAME, items);
        break;
      case 'save':
        result = await wixData.bulkSave(MEMORY_CONFIG.COLLECTION_NAME, items);
        break;
      default:
        return badRequest({ error: 'Invalid operation', supportedOperations: ['insert', 'update', 'save'] });
    }
    
    return ok({
      success: true,
      operation,
      inserted: result.inserted || [],
      updated: result.updated || [],
      errors: result.errors || [],
      apiVersion: 'expert'
    });
  } catch (error) {
    console.error('Expert bulk operation error:', error);
    return serverError({ error: 'Bulk operation failed', details: error.message });
  }
}

// ===== 🔥 OPTIMIZED LEVEL OPERATIONS =====

async function getMemoriesOptimized(query) {
  const { 
    userId, 
    type = 'memory', 
    limit = 25, 
    skip = 0, 
    search = null,
    startDate = null,
    endDate = null 
  } = query;
  
  if (!userId) {
    return badRequest({ error: 'userId is required' });
  }
  
  try {
    const builder = new WixUtilsMaster(MEMORY_CONFIG.COLLECTION_NAME, 'optimized')
      .forUser(userId)
      .ofType(type);
    
    if (search) {
      builder.searchContent(search);
    }
    
    if (startDate || endDate) {
      builder.dateRange(startDate ? new Date(startDate) : null, 
                       endDate ? new Date(endDate) : null);
    }
    
    const result = await builder
      .sortBy('_createdDate', 'desc')
      .paginate(Number(limit), Number(skip))
      .execute({ consistentRead: true });
    
    return ok({
      success: true,
      data: result.items,
      totalCount: result.totalCount,
      analytics: result._indexAnalysis,
      performance: {
        queryDuration: result._indexAnalysis.duration,
        indexScore: result._indexAnalysis.indexScore,
        isOptimized: result._indexAnalysis.isOptimized
      },
      apiVersion: 'optimized'
    });
  } catch (error) {
    console.error('Optimized get memories error, falling back to expert:', error);
    return await getMemoriesExpert(query);
  }
}

async function saveMemoryOptimized(body) {
  const validation = validateMemoryData(body, 'optimized');
  if (!validation.isValid) {
    return badRequest({ error: 'Validation failed', details: validation.errors });
  }
  
  try {
    const startTime = Date.now();
    
    const memoryData = {
      ...body,
      type: body.type || 'memory',
      timestamp: new Date(),
      metadata: {
        ...body.metadata,
        apiVersion: 'optimized',
        createdAt: new Date().toISOString(),
        indexOptimized: true
      }
    };
    
    const result = await wixData.insert(MEMORY_CONFIG.COLLECTION_NAME, memoryData);
    const duration = Date.now() - startTime;
    
    return ok({
      success: true,
      data: result,
      performance: {
        insertDuration: duration,
        indexOptimized: true
      },
      apiVersion: 'optimized'
    });
  } catch (error) {
    console.error('Optimized save memory error, falling back to expert:', error);
    return await saveMemoryExpert(body);
  }
}

async function updateMemoryOptimized(body) {
  const { _id, ...updateData } = body;
  
  if (!_id) {
    return badRequest({ error: '_id is required for update' });
  }
  
  try {
    const startTime = Date.now();
    
    // Use optimized get with index
    const existing = await wixData.get(MEMORY_CONFIG.COLLECTION_NAME, _id, { consistentRead: true });
    if (!existing) {
      return notFound({ error: 'Memory not found', _id });
    }
    
    const result = await wixData.update(MEMORY_CONFIG.COLLECTION_NAME, {
      _id,
      ...updateData,
      _updatedDate: new Date(),
      metadata: {
        ...existing.metadata,
        ...updateData.metadata,
        lastUpdated: new Date().toISOString(),
        apiVersion: 'optimized'
      }
    });
    
    const duration = Date.now() - startTime;
    
    return ok({
      success: true,
      data: result,
      performance: {
        updateDuration: duration,
        indexOptimized: true
      },
      apiVersion: 'optimized'
    });
  } catch (error) {
    console.error('Optimized update memory error, falling back to expert:', error);
    return await updateMemoryExpert(body);
  }
}

async function deleteMemoryOptimized(query) {
  const { _id } = query;
  
  if (!_id) {
    return badRequest({ error: '_id is required for delete' });
  }
  
  try {
    const startTime = Date.now();
    
    // Check existence with optimized query
    const existing = await wixData.get(MEMORY_CONFIG.COLLECTION_NAME, _id, { consistentRead: true });
    if (!existing) {
      return notFound({ error: 'Memory not found', _id });
    }
    
    await wixData.remove(MEMORY_CONFIG.COLLECTION_NAME, _id);
    const duration = Date.now() - startTime;
    
    return ok({
      success: true,
      message: 'Memory deleted successfully',
      deletedId: _id,
      performance: {
        deleteDuration: duration,
        indexOptimized: true
      },
      apiVersion: 'optimized'
    });
  } catch (error) {
    console.error('Optimized delete memory error, falling back to expert:', error);
    return await deleteMemoryExpert(query);
  }
}

async function bulkOperationOptimized(body) {
  const { operation, items } = body;
  
  if (!operation || !Array.isArray(items)) {
    return badRequest({ error: 'operation and items array are required' });
  }
  
  if (items.length > MEMORY_CONFIG.VALIDATION.MAX_BATCH_SIZE) {
    return badRequest({ 
      error: `Batch size exceeds maximum of ${MEMORY_CONFIG.VALIDATION.MAX_BATCH_SIZE}` 
    });
  }
  
  try {
    const startTime = Date.now();
    
    // Add optimized metadata to items
    const optimizedItems = items.map(item => ({
      ...item,
      metadata: {
        ...item.metadata,
        batchOptimized: true,
        apiVersion: 'optimized'
      }
    }));
    
    let result;
    switch (operation) {
      case 'insert':
        result = await wixData.bulkInsert(MEMORY_CONFIG.COLLECTION_NAME, optimizedItems);
        break;
      case 'update':
        result = await wixData.bulkUpdate(MEMORY_CONFIG.COLLECTION_NAME, optimizedItems);
        break;
      case 'save':
        result = await wixData.bulkSave(MEMORY_CONFIG.COLLECTION_NAME, optimizedItems);
        break;
      default:
        return badRequest({ error: 'Invalid operation', supportedOperations: ['insert', 'update', 'save'] });
    }
    
    const duration = Date.now() - startTime;
    
    return ok({
      success: true,
      operation,
      inserted: result.inserted || [],
      updated: result.updated || [],
      errors: result.errors || [],
      performance: {
        bulkDuration: duration,
        itemsPerSecond: Math.round(items.length / (duration / 1000)),
        indexOptimized: true
      },
      apiVersion: 'optimized'
    });
  } catch (error) {
    console.error('Optimized bulk operation error, falling back to expert:', error);
    return await bulkOperationExpert(body);
  }
}

// ===== 🛠️ UTILITY FUNCTIONS =====

function validateMemoryData(data, level = 'basic') {
  const errors = [];
  
  // Required fields
  for (const field of MEMORY_CONFIG.VALIDATION.REQUIRED_FIELDS) {
    if (!data[field]) {
      errors.push(`${field} is required`);
    }
  }
  
  // Content length validation
  if (data.memoryContent && data.memoryContent.length > MEMORY_CONFIG.VALIDATION.MAX_CONTENT_LENGTH) {
    errors.push(`memoryContent exceeds maximum length of ${MEMORY_CONFIG.VALIDATION.MAX_CONTENT_LENGTH}`);
  }
  
  // Type validation for expert/optimized levels
  if (level !== 'basic') {
    if (data.type && typeof data.type !== 'string') {
      errors.push('type must be a string');
    }
    
    if (data.metadata && typeof data.metadata !== 'object') {
      errors.push('metadata must be an object');
    }
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

async function resilientQuery(fallbackFn, originalError) {
  try {
    return await fallbackFn();
  } catch (fallbackError) {
    console.error('Fallback also failed:', fallbackError);
    return serverError({ 
      error: 'All fallback attempts failed', 
      originalError: originalError.message,
      fallbackError: fallbackError.message
    });
  }
}

function updateMetrics(apiVersion, duration, status) {
  if (status === 'success') {
    memoryMetrics[apiVersion === 'GET' ? 'reads' : 'writes']++;
  } else {
    memoryMetrics.errors++;
  }
  
  memoryMetrics.totalDuration += duration;
  memoryMetrics.byVersion[apiVersion].requests++;
  memoryMetrics.byVersion[apiVersion].duration += duration;
  
  if (duration > MEMORY_CONFIG.PERFORMANCE.SLOW_QUERY_THRESHOLD) {
    memoryMetrics.slowQueries++;
  }
}

// 🔄 GET METRICS ENDPOINT (Expert/Optimized only)
export async function get_userMemoryMetrics(request) {
  const apiVersion = request.headers['x-api-version'] || 'expert';
  
  if (apiVersion === 'basic') {
    return badRequest({ error: 'Metrics not available for basic API version' });
  }
  
  const avgDuration = memoryMetrics.reads + memoryMetrics.writes > 0 ? 
    Math.round(memoryMetrics.totalDuration / (memoryMetrics.reads + memoryMetrics.writes)) : 0;
  
  return ok({
    metrics: {
      ...memoryMetrics,
      averageDuration: avgDuration,
      successRate: Math.round(((memoryMetrics.reads + memoryMetrics.writes - memoryMetrics.errors) / 
                              (memoryMetrics.reads + memoryMetories.writes)) * 100) || 100
    },
    timestamp: new Date().toISOString(),
    apiVersion
  });
}

// Export main function and utilities
export { post_userMemory as default };
