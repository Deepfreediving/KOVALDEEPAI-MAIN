// üî• HTTP-CHAT-MASTER.JSW - ALL-IN-ONE CHAT API
// Consolidates: http-chat.jsw + http-chat-expert.jsw (empty)
// Version: 4.0.0 - Master Consolidated Edition
// Date: August 8, 2025

import wixData from 'wix-data';
import { fetch } from 'wix-fetch';
import { currentMember } from 'wix-members';
import { ok, badRequest, serverError } from 'wix-http-functions';

// üéØ MASTER CONFIGURATION
const CHAT_CONFIG = {
  API_VERSIONS: {
    BASIC: 'basic',           // Simple chat forwarding
    EXPERT: 'expert',         // Enhanced member detection + analytics
    OPTIMIZED: 'optimized'    // Performance tracking + smart caching
  },
  
  API_ENDPOINTS: {
    AI_BACKEND: 'https://kovaldeepai-main.vercel.app/api/openai/chat',
    LOCAL_DIVE_LOGS: 'https://kovaldeepai-main.vercel.app/api/analyze/dive-logs',
    FALLBACK_BACKEND: 'https://kovaldeepai-main.vercel.app/api/chat'
  },
  
  COLLECTION_NAME: '@deepfreediving/kovaldeepai-app/Import1',
  
  VALIDATION: {
    MAX_MESSAGE_LENGTH: 5000,
    MIN_MESSAGE_LENGTH: 1,
    MAX_DIVE_LOGS: 20,
    KNOWN_MEMBER_IDS: [
      '8b315b71-22b9-40c6-af86-841ceee3f534',
      'f549b01d-9dc1-4c85-90b9-1683337f6ed0'
    ]
  },
  
  PERFORMANCE: {
    SLOW_QUERY_THRESHOLD: 3000,
    ENABLE_ANALYTICS: true,
    CACHE_TTL: 300000,        // 5 minutes
    REQUEST_TIMEOUT: 15000    // 15 seconds
  },
  
  ERROR_MESSAGES: {
    MISSING_MESSAGE: 'Message is required',
    MESSAGE_TOO_LONG: 'Message exceeds maximum length',
    AI_BACKEND_ERROR: 'AI service temporarily unavailable',
    MEMBER_NOT_FOUND: 'Could not identify member',
    DIVE_LOGS_ERROR: 'Could not load dive logs'
  }
};

// üî• CORS HEADERS
const CORS_HEADERS = {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-API-Version'
};

// üî• PERFORMANCE METRICS (Expert/Optimized levels)
let chatMetrics = {
  requests: 0,
  responses: 0,
  errors: 0,
  totalDuration: 0,
  memberDetections: 0,
  diveLogsRetrieved: 0,
  aiBackendCalls: 0,
  slowRequests: 0,
  byVersion: {
    basic: { requests: 0, duration: 0 },
    expert: { requests: 0, duration: 0 },
    optimized: { requests: 0, duration: 0 }
  }
};

// üî• UTILITY FUNCTIONS
function getApiVersion(request) {
  return request.headers['x-api-version'] || 
         request.query.version || 
         CHAT_CONFIG.API_VERSIONS.EXPERT; // Default to expert
}

function createResponse(status, data, request) {
  return {
    status,
    body: data,
    headers: CORS_HEADERS
  };
}

function trackMetrics(version, operation, duration, success = true) {
  chatMetrics.requests++;
  chatMetrics.byVersion[version].requests++;
  chatMetrics.byVersion[version].duration += duration;
  chatMetrics.totalDuration += duration;
  
  if (success) {
    chatMetrics.responses++;
  } else {
    chatMetrics.errors++;
  }
  
  if (duration > CHAT_CONFIG.PERFORMANCE.SLOW_QUERY_THRESHOLD) {
    chatMetrics.slowRequests++;
    console.log(`üêå Slow chat request: ${duration}ms`);
  }
  
  // Track specific operations
  switch(operation) {
    case 'memberDetection':
      chatMetrics.memberDetections++;
      break;
    case 'diveLogsRetrieval':
      chatMetrics.diveLogsRetrieved++;
      break;
    case 'aiBackendCall':
      chatMetrics.aiBackendCalls++;
      break;
  }
}

function logDebug(message, data = null, version = 'expert') {
  if (version !== 'basic') {
    console.log(message, data || '');
  }
}

function logError(message, error = null) {
  console.error(message, error || '');
}

// üî• ENHANCED MEMBER DETECTION
async function detectMember(userId, version = 'expert') {
  const startTime = Date.now();
  
  try {
    let effectiveUserId = userId || 'member';
    
    // Expert/Optimized: Enhanced member detection
    if (version !== 'basic' && effectiveUserId.startsWith('guest-')) {
      logDebug('‚ö†Ô∏è Guest user detected, attempting member resolution...', null, version);
      
      try {
        // Try to get the real user ID from Wix Members service
        const member = await currentMember.getMember();
        if (member && member._id) {
          effectiveUserId = member._id;
          logDebug(`‚úÖ Found actual member ID: ${effectiveUserId}`, null, version);
        }
      } catch (memberError) {
        logDebug('‚ö†Ô∏è Could not get member from wix-members:', memberError.message, version);
        
        // Fallback: Try known member IDs
        for (const testId of CHAT_CONFIG.VALIDATION.KNOWN_MEMBER_IDS) {
          try {
            const testResults = await wixData.query(CHAT_CONFIG.COLLECTION_NAME)
              .eq("userId", testId)
              .limit(1)
              .find();
            
            if (testResults.items.length > 0) {
              effectiveUserId = testId;
              logDebug(`‚úÖ Using known member ID with dive logs: ${effectiveUserId}`, null, version);
              break;
            }
          } catch (testError) {
            logDebug(`‚ö†Ô∏è Test failed for member ID ${testId}:`, testError.message, version);
          }
        }
      }
    }
    
    const duration = Date.now() - startTime;
    trackMetrics(version, 'memberDetection', duration);
    
    return effectiveUserId;
    
  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics(version, 'memberDetection', duration, false);
    throw error;
  }
}

// üî• ENHANCED DIVE LOGS RETRIEVAL
async function retrieveDiveLogs(userId, providedLogs = [], version = 'expert') {
  const startTime = Date.now();
  
  try {
    let userDiveLogs = providedLogs;
    
    if (!userDiveLogs.length && userId) {
      logDebug(`üîç Querying dive logs for member: ${userId}`, null, version);
      
      // Query Wix database
      const results = await wixData.query(CHAT_CONFIG.COLLECTION_NAME)
        .eq("userId", userId)
        .and(wixData.query(CHAT_CONFIG.COLLECTION_NAME)
          .or(
            wixData.query(CHAT_CONFIG.COLLECTION_NAME).isNotEmpty("discipline"),
            wixData.query(CHAT_CONFIG.COLLECTION_NAME).isNotEmpty("targetDepth")
          )
        )
        .descending("timestamp")
        .limit(CHAT_CONFIG.VALIDATION.MAX_DIVE_LOGS)
        .find();
        
      userDiveLogs = results.items;
      logDebug(`‚úÖ Retrieved ${userDiveLogs.length} dive logs from Wix database`, null, version);
      
      // Expert/Optimized: Fallback strategies if no logs found
      if (version !== 'basic' && userDiveLogs.length === 0) {
        logDebug('üîç No dive logs found, checking database contents...', null, version);
        
        // Check for any dive logs in the database
        const anyLogs = await wixData.query(CHAT_CONFIG.COLLECTION_NAME)
          .limit(5)
          .find();
        
        logDebug(`üìä Total items in database: ${anyLogs.totalCount}`, null, version);
        
        if (anyLogs.items.length > 0) {
          logDebug('üìã Sample items found in database', anyLogs.items.map(item => ({
            id: item._id,
            userId: item.userId,
            discipline: item.discipline,
            targetDepth: item.targetDepth,
            reachedDepth: item.reachedDepth
          })), version);
          
          // Use fallback logs if available
          const fallbackLogs = anyLogs.items.filter(item => 
            item.discipline || item.targetDepth
          );
          
          if (fallbackLogs.length > 0) {
            userDiveLogs = fallbackLogs;
            logDebug(`‚úÖ Using ${fallbackLogs.length} fallback dive logs for analysis`, null, version);
          }
        }
        
        // Try local dive logs API
        if (userDiveLogs.length === 0) {
          try {
            logDebug('üîç Checking local dive logs API...', null, version);
            
            const localResponse = await fetch(`${CHAT_CONFIG.API_ENDPOINTS.LOCAL_DIVE_LOGS}?userId=${userId}`);
            if (localResponse.ok) {
              const localData = await localResponse.json();
              if (localData.success && localData.data && localData.data.length > 0) {
                userDiveLogs = localData.data;
                logDebug(`‚úÖ Retrieved ${userDiveLogs.length} local dive logs`, null, version);
                
                if (version === 'optimized' && userDiveLogs.length > 0) {
                  logDebug('üìä Sample local dive log:', {
                    discipline: userDiveLogs[0].discipline,
                    depth: userDiveLogs[0].reachedDepth,
                    date: userDiveLogs[0].date,
                    location: userDiveLogs[0].location,
                    notes: userDiveLogs[0].notes
                  }, version);
                }
              }
            }
          } catch (localError) {
            logDebug('‚ö†Ô∏è Could not load local dive logs:', localError.message, version);
          }
        }
      }
    }
    
    const duration = Date.now() - startTime;
    trackMetrics(version, 'diveLogsRetrieval', duration);
    
    return userDiveLogs;
    
  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics(version, 'diveLogsRetrieval', duration, false);
    logError('Could not load dive logs:', error);
    return [];
  }
}

// üî• ENHANCED AI BACKEND CALL
async function callAIBackend(payload, version = 'expert') {
  const startTime = Date.now();
  
  try {
    logDebug("üöÄ Sending to AI backend:", {
      userId: payload.userId,
      message: payload.message.substring(0, 50) + '...',
      profileSummary: `PB: ${payload.profile.pb || 'Unknown'}, Dives: ${payload.profile.totalDives}`
    }, version);

    const response = await fetch(CHAT_CONFIG.API_ENDPOINTS.AI_BACKEND, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      throw new Error(`AI backend responded with status: ${response.status}`);
    }

    const data = await response.json();
    
    const duration = Date.now() - startTime;
    trackMetrics(version, 'aiBackendCall', duration);
    
    logDebug("üì• AI backend response received", data, version);
    
    return data;
    
  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics(version, 'aiBackendCall', duration, false);
    throw error;
  }
}

// üî• MAIN CHAT ENDPOINT

/**
 * POST: Handle chat requests with version-based features
 * Supports basic, expert, and optimized modes
 */
export async function post_chat(request) {
  const startTime = Date.now();
  const version = getApiVersion(request);
  
  try {
    const requestData = await request.body.json();
    const { userMessage, userId, profile = {}, diveLogs = [] } = requestData;
    
    logDebug('üì• Chat request received:', {
      userMessage: userMessage?.substring(0, 50) + '...',
      userId: userId,
      profileKeys: Object.keys(profile),
      diveLogsCount: diveLogs.length,
      version: version
    }, version);

    // Validation
    if (!userMessage?.trim()) {
      trackMetrics(version, 'validation', Date.now() - startTime, false);
      return createResponse(400, {
        error: CHAT_CONFIG.ERROR_MESSAGES.MISSING_MESSAGE,
        success: false
      }, request);
    }

    if (userMessage.length > CHAT_CONFIG.VALIDATION.MAX_MESSAGE_LENGTH) {
      trackMetrics(version, 'validation', Date.now() - startTime, false);
      return createResponse(400, {
        error: CHAT_CONFIG.ERROR_MESSAGES.MESSAGE_TOO_LONG,
        success: false
      }, request);
    }

    // Enhanced member detection (expert/optimized)
    const effectiveUserId = await detectMember(userId, version);
    logDebug(`üîç Processing request for member: ${effectiveUserId}`, null, version);

    // Enhanced dive logs retrieval (expert/optimized)
    const userDiveLogs = await retrieveDiveLogs(effectiveUserId, diveLogs, version);

    // Build enhanced profile context
    const userProfile = {
      ...profile,
      totalDives: userDiveLogs.length,
      pb: userDiveLogs.reduce(
        (max, d) => Math.max(max, d.reachedDepth || d.targetDepth || 0),
        0
      ),
      lastDiveDepth: userDiveLogs[0]?.reachedDepth || userDiveLogs[0]?.targetDepth || 0,
      lastDiveLocation: userDiveLogs[0]?.location || "Unknown"
    };

    // Expert/Optimized: Add metadata
    if (version !== 'basic') {
      userProfile.analysisTimestamp = new Date().toISOString();
      userProfile.apiVersion = version;
      userProfile.memberDetectionMethod = userId?.startsWith('guest-') ? 'enhanced' : 'direct';
    }

    // Prepare AI payload
    const payload = {
      message: userMessage,
      userId: effectiveUserId,
      profile: userProfile,
      diveLogs: userDiveLogs
    };

    // Expert/Optimized: Add request context
    if (version !== 'basic') {
      payload.context = {
        version: version,
        timestamp: new Date().toISOString(),
        diveLogsSource: userDiveLogs.length > 0 ? 'wix-database' : 'none',
        performanceTracking: true
      };
    }

    // Call AI backend
    const data = await callAIBackend(payload, version);

    // Extract AI response
    const aiResponse = data.assistantMessage?.content || 
                      data.answer || 
                      "‚ö†Ô∏è No response from AI.";

    const duration = Date.now() - startTime;
    trackMetrics(version, 'complete', duration, true);

    // Build response
    const response = {
      aiResponse,
      metadata: {
        ...data.metadata,
        userProfile,
        totalDiveLogs: userDiveLogs.length
      },
      success: true,
      timestamp: new Date().toISOString()
    };

    // Expert/Optimized: Add enhanced metadata
    if (version !== 'basic') {
      response.performance = {
        duration: `${duration}ms`,
        version: version,
        memberDetection: effectiveUserId !== userId ? 'enhanced' : 'direct',
        diveLogsFound: userDiveLogs.length
      };
      
      if (version === 'optimized') {
        response.metrics = {
          requestCount: chatMetrics.requests,
          averageResponseTime: chatMetrics.requests > 0 ? chatMetrics.totalDuration / chatMetrics.requests : 0,
          successRate: chatMetrics.requests > 0 ? (chatMetrics.responses / chatMetrics.requests) * 100 : 0
        };
      }
    }

    return createResponse(200, response, request);

  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics(version, 'error', duration, false);
    
    logError("‚ùå Chat function error:", error);
    
    return createResponse(500, {
      error: 'Chat service error: ' + error.message,
      success: false,
      timestamp: new Date().toISOString(),
      version: version
    }, request);
  }
}

/**
 * GET: Retrieve chat metrics (expert/optimized only)
 */
export async function get_chatMetrics(request) {
  const version = getApiVersion(request);
  
  if (version === 'basic') {
    return createResponse(403, {
      error: 'Metrics available in expert/optimized versions only',
      success: false
    }, request);
  }
  
  return createResponse(200, {
    success: true,
    metrics: chatMetrics,
    config: CHAT_CONFIG,
    version: version
  }, request);
}

/**
 * OPTIONS: Handle CORS preflight requests
 */
export function options_chat(request) {
  return createResponse(200, {}, request);
}

// üî• BACKWARD COMPATIBILITY LAYER
// Legacy function names for existing integrations
export const forwardChatRequest = post_chat;
export const handleChatRequest = post_chat;

console.log("üî• Chat Master API initialized - All versions supported");
