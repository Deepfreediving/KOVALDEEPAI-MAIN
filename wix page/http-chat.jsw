// ===== üìÑ http-chat.jsw - CHAT ENDPOINT =====
// Forward chat requests from Wix frontend to your deployed AI backend

import wixData from 'wix-data';
import { fetch } from 'wix-fetch';
import { currentMember } from 'wix-members';
import { API_ENDPOINTS, ERROR_MESSAGES, CORS_HEADERS } from 'backend/config/constants.jsw';

/**
 * ‚úÖ Forward chat requests from Wix frontend to your deployed AI backend
 */
export async function post_chat(request) {
    try {
        const { userMessage, userId, profile = {}, diveLogs = [] } = request.body;
        
        console.log('üì• Chat request received:', {
            userMessage: userMessage?.substring(0, 50) + '...',
            userId: userId,
            profileKeys: Object.keys(profile),
            diveLogsCount: diveLogs.length
        });

        // ‚úÖ Validate required inputs
        if (!userMessage?.trim()) {
            console.error('‚ùå Empty message received');
            return {
                status: 400,
                body: {
                    error: ERROR_MESSAGES.MISSING_MESSAGE,
                    success: false
                },
                headers: CORS_HEADERS
            };
        }

        // Since this is a private page accessible only to authenticated members,
        // we trust that Wix handles authentication at the page level
        let effectiveUserId = userId || 'member';
        
        // ‚úÖ DEBUGGING: If userId looks like a guest ID, try to map to real member ID
        if (effectiveUserId.startsWith('guest-')) {
            console.log('‚ö†Ô∏è Guest user detected, checking for actual member session...');
            
            // Try to get the real user ID from Wix Users service
            try {
                // In Wix backend, we can use wix-members to get the current user
                const member = await currentMember.getMember();
                if (member && member._id) {
                    effectiveUserId = member._id;
                    console.log('‚úÖ Found actual member ID:', effectiveUserId);
                }
            } catch (memberError) {
                console.warn('‚ö†Ô∏è Could not get member from wix-members:', memberError);
                
                // Fallback: Try common member IDs from your dive logs
                const knownMemberIds = [
                    '8b315b71-22b9-40c6-af86-841ceee3f534',
                    'f549b01d-9dc1-4c85-90b9-1683337f6ed0'
                ];
                
                // Test each known member ID to see if they have dive logs
                for (const testId of knownMemberIds) {
                    try {
                        const testResults = await wixData.query("@deepfreediving/kovaldeepai-app/Import1")
                            .eq("userId", testId)
                            .limit(1)
                            .find();
                        
                        if (testResults.items.length > 0) {
                            effectiveUserId = testId;
                            console.log('‚úÖ Using known member ID with dive logs:', effectiveUserId);
                            break;
                        }
                    } catch (testError) {
                        console.warn(`‚ö†Ô∏è Test failed for member ID ${testId}:`, testError);
                    }
                }
            }
        }
        
        console.log('üîç Processing request for member:', effectiveUserId);

        // ‚úÖ Retrieve dive logs if not provided
        let userDiveLogs = diveLogs;
        if (!userDiveLogs.length && effectiveUserId) {
            try {
                console.log('üîç Querying dive logs for member:', effectiveUserId);
                const results = await wixData.query("@deepfreediving/kovaldeepai-app/Import1")
                    .eq("userId", effectiveUserId)
                    .and(wixData.query("@deepfreediving/kovaldeepai-app/Import1")
                        .or(
                            wixData.query("@deepfreediving/kovaldeepai-app/Import1").isNotEmpty("discipline"),
                            wixData.query("@deepfreediving/kovaldeepai-app/Import1").isNotEmpty("targetDepth")
                        )
                    )
                    .descending("timestamp")
                    .limit(10)
                    .find();
                    
                userDiveLogs = results.items;
                console.log(`‚úÖ Retrieved ${userDiveLogs.length} dive logs from Wix database for member ${effectiveUserId}`);
                
                // ‚úÖ DEBUGGING: If no logs found, try to see what's actually in the database
                if (userDiveLogs.length === 0) {
                    console.log('üîç No dive logs found, checking database contents...');
                    
                    // Check if there are ANY dive logs in the database
                    const anyLogs = await wixData.query("@deepfreediving/kovaldeepai-app/Import1")
                        .limit(5)
                        .find();
                    
                    console.log(`üìä Total items in database: ${anyLogs.totalCount}`);
                    console.log(`üìã Sample items:`, anyLogs.items.map(item => ({
                        id: item._id,
                        userId: item.userId,
                        discipline: item.discipline,
                        targetDepth: item.targetDepth,
                        reachedDepth: item.reachedDepth
                    })));
                    
                    // Try to find logs with any userId pattern that might match
                    if (anyLogs.items.length > 0) {
                        console.log('üîÑ Found dive logs in database, attempting to match with current user...');
                        
                        // If there are logs but none match our user ID, use the most recent ones as a fallback
                        const fallbackLogs = anyLogs.items.filter(item => 
                            item.discipline || item.targetDepth
                        );
                        
                        if (fallbackLogs.length > 0) {
                            userDiveLogs = fallbackLogs;
                            console.log(`‚úÖ Using ${fallbackLogs.length} fallback dive logs for analysis`);
                        }
                    }
                }
                
            } catch (diveLogError) {
                console.warn("‚ö†Ô∏è Could not load dive logs from Wix:", diveLogError);
                userDiveLogs = [];
            }
        }

        // ‚úÖ Build profile context for AI
        const userProfile = {
            ...profile,
            totalDives: userDiveLogs.length,
            pb: userDiveLogs.reduce(
                (max, d) => Math.max(max, d.reachedDepth || d.targetDepth || 0),
                0
            ),
            lastDiveDepth: userDiveLogs[0]?.reachedDepth || userDiveLogs[0]?.targetDepth || 0,
            lastDiveLocation: userDiveLogs[0]?.location || "Unknown"
        };

        // ‚úÖ Send query to Next.js AI backend
        const payload = {
            message: userMessage,  // ‚úÖ Use 'message' for Next.js backend
            userId: effectiveUserId,
            profile: userProfile,
            diveLogs: userDiveLogs  // ‚úÖ Include dive logs in payload
        };

        console.log("üöÄ Sending to AI backend for member:", {
            userId: effectiveUserId,
            message: payload.message.substring(0, 50) + '...',
            profileSummary: `PB: ${userProfile.pb || 'Unknown'}, Dives: ${userProfile.totalDives}`
        });

        const response = await fetch(API_ENDPOINTS.AI_BACKEND, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            console.error(`‚ùå AI backend responded with status: ${response.status}`);
            return {
                status: response.status,
                body: {
                    error: `AI backend error: ${response.status}`,
                    success: false
                },
                headers: CORS_HEADERS
            };
        }

        const data = await response.json();
        console.log("üì• AI backend response:", data);

        // ‚úÖ Handle the correct response structure from chat-embed.ts
        const aiResponse = data.assistantMessage?.content || 
                          data.answer || 
                          "‚ö†Ô∏è No response from AI.";

        return {
            status: 200,
            body: {
                aiResponse,
                metadata: {
                    ...data.metadata,
                    userProfile,
                    totalDiveLogs: userDiveLogs.length
                },
                success: true,
                timestamp: new Date().toISOString()
            },
            headers: CORS_HEADERS
        };

    } catch (error) {
        console.error("‚ùå Chat function error:", error);
        return {
            status: 500,
            body: {
                error: 'Chat service error: ' + error.message,
                success: false,
                timestamp: new Date().toISOString()
            },
            headers: CORS_HEADERS
        };
    }
}

/**
 * ‚úÖ Handle OPTIONS requests for CORS
 */
export function options_chat(request) {
    return {
        status: 200,
        headers: CORS_HEADERS
            'Access-Control-Allow-Headers': 'Content-Type, Authorization'
        }
    };
}
