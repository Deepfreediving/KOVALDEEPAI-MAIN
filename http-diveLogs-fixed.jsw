// =======================================================
// üìÑ File: http-diveLogs.jsw - FIXED VERSION
// Description: Backend HTTP functions for managing user dive logs.
// Includes GET, POST, and OPTIONS endpoints with semantic search via Next.js API
// =======================================================

import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { fetch } from 'wix-fetch';
import {
    successResponse,
    badRequestResponse,
    serverErrorResponse,
    baseResponse,
    unauthorizedResponse
} from 'backend/http-utils.jsw';

// ‚úÖ CONFIGURATION
const COLLECTION_ID = "@deepfreediving/kovaldeepai-app/Import1";
const SEMANTIC_SEARCH_API = "https://kovaldeepai-main.vercel.app/api/pinecone";
const MEMORY_SYNC_API = "https://kovaldeepai-main.vercel.app/api/userMemory/sync";
const MAX_RESULTS = 100;

/**
 * ‚úÖ OPTIONS: Preflight requests
 */
export function options_diveLogs(request) {
    return baseResponse(204, request);
}

/**
 * ‚úÖ GET: Load user dive logs with enhanced search capabilities
 */
export async function get_diveLogs(request) {
    try {
        // ‚úÖ IMPROVED USER IDENTIFICATION
        let userId = request.query?.userId;
        
        // Try to get authenticated user
        try {
            const currentUser = await wixUsersBackend.currentUser;
            if (currentUser?.id) {
                userId = currentUser.id;
            }
        } catch (authError) {
            console.log("‚ÑπÔ∏è No authenticated user, using query userId");
        }

        if (!userId) {
            return unauthorizedResponse(request, "User not identified. Please provide userId parameter or log in.");
        }

        const { 
            q: searchQuery, 
            limit = 50, 
            skip = 0,
            discipline,
            location,
            minDepth,
            maxDepth,
            dateFrom,
            dateTo,
            sortBy = 'timestamp',
            sortOrder = 'desc'
        } = request.query;

        console.log(`üìä Loading dive logs for user: ${userId}`);
        console.log(`üîç Search query: "${searchQuery}", filters applied: ${!!discipline || !!location || !!minDepth}`);

        let items = [];
        let totalCount = 0;
        let searchType = 'database';

        // ‚úÖ SEMANTIC SEARCH if query provided
        if (searchQuery && searchQuery.trim().length > 2) {
            const semanticResults = await performSemanticDiveSearch(searchQuery, userId, parseInt(limit));
            if (semanticResults.success) {
                items = semanticResults.data.filter(item => isDiveLog(item));
                totalCount = items.length;
                searchType = 'semantic';
            } else {
                console.warn("‚ö†Ô∏è Semantic search failed, falling back to database search");
            }
        }

        // ‚úÖ DATABASE SEARCH (if no query or semantic search failed)
        if (!searchQuery || searchType === 'database') {
            const dbResults = await performDiveLogDatabaseSearch(
                userId, searchQuery, parseInt(limit), parseInt(skip), 
                { discipline, location, minDepth, maxDepth, dateFrom, dateTo },
                sortBy, sortOrder
            );
            items = dbResults.items;
            totalCount = dbResults.totalCount;
            searchType = 'database';
        }

        // ‚úÖ ENHANCE ITEMS WITH COMPUTED FIELDS
        const enhancedItems = items.map(item => ({
            ...item,
            searchType,
            // Computed fields
            depthAchieved: item.reachedDepth || item.targetDepth || 0,
            depthProgress: item.reachedDepth && item.targetDepth ? 
                Math.round((item.reachedDepth / item.targetDepth) * 100) : 0,
            hasNotes: !!(item.notes && item.notes.trim()),
            daysSinceLog: item.timestamp ? 
                Math.floor((new Date() - new Date(item.timestamp)) / (1000 * 60 * 60 * 24)) : 0,
            isDiveLog: true
        }));

        return successResponse(request, {
            success: true,
            count: enhancedItems.length,
            totalCount,
            data: enhancedItems,
            searchType,
            query: searchQuery,
            userId,
            pagination: {
                limit: parseInt(limit),
                skip: parseInt(skip),
                hasMore: parseInt(skip) + enhancedItems.length < totalCount
            }
        });

    } catch (err) {
        console.error("‚ùå get_diveLogs error:", err);
        return serverErrorResponse(request, "Server error retrieving dive logs", err);
    }
}

/**
 * ‚úÖ POST: Save a new dive log with improved validation and sync
 */
export async function post_diveLogs(request) {
    try {
        // ‚úÖ USER IDENTIFICATION
        let userId;
        try {
            const currentUser = await wixUsersBackend.currentUser;
            userId = currentUser?.id;
        } catch (authError) {
            console.log("‚ÑπÔ∏è No authenticated user");
        }

        // ‚úÖ PARSE REQUEST BODY
        const body = await parseRequestBody(request);
        
        if (!userId && body.userId) {
            userId = body.userId;
        }

        if (!userId) {
            return unauthorizedResponse(request, "User not identified");
        }

        if (!body.diveLog) {
            return badRequestResponse(request, "Missing diveLog data");
        }

        console.log("üíæ Saving dive log for user:", userId);

        // ‚úÖ VALIDATE DIVE LOG DATA
        const validationError = validateDiveLog(body.diveLog);
        if (validationError) {
            return badRequestResponse(request, validationError);
        }

        // ‚úÖ PREPARE DIVE LOG ENTRY
        const timestamp = new Date();
        const uniqueKey = body.diveLog.id || `${userId}-dive-${timestamp.getTime()}`;

        const log = {
            userId,
            uniqueKey,
            timestamp,
            type: 'diveLog',
            source: 'wix-backend',
            ...mapDiveLogFields(body.diveLog)
        };

        // ‚úÖ SAVE TO WIX DATABASE
        let saved;
        try {
            // Check if log already exists
            const existing = await wixData.query(COLLECTION_ID)
                .eq("userId", userId)
                .eq("uniqueKey", uniqueKey)
                .find();

            if (existing.items.length > 0) {
                // Update existing
                saved = await wixData.update(COLLECTION_ID, {
                    _id: existing.items[0]._id,
                    ...log
                });
                console.log("‚úÖ Updated existing dive log");
            } else {
                // Insert new
                saved = await wixData.insert(COLLECTION_ID, log);
                console.log("‚úÖ Inserted new dive log");
            }
        } catch (dbError) {
            console.error("‚ùå Database save error:", dbError);
            return serverErrorResponse(request, "Failed to save dive log to database");
        }

        // ‚úÖ SYNC TO NEXT.JS BACKEND (non-blocking)
        syncDiveLogToBackend(saved).catch(err => {
            console.warn("‚ö†Ô∏è Backend sync failed:", err.message);
        });

        return successResponse(request, {
            success: true,
            message: "Dive log saved successfully",
            data: saved,
            diveLogId: saved._id,
            timestamp: timestamp.toISOString()
        });

    } catch (err) {
        console.error("‚ùå post_diveLogs error:", err);
        return serverErrorResponse(request, "Server error saving dive log", err);
    }
}

/**
 * ‚úÖ PERFORM SEMANTIC DIVE SEARCH via Next.js API
 */
async function performSemanticDiveSearch(query, userId, limit = 20) {
    try {
        console.log("üîç Performing semantic dive search via Next.js API");

        const response = await fetch(SEMANTIC_SEARCH_API, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'query',
                query: `dive log ${query}`, // Prefix to focus on dive logs
                topK: limit,
                filter: { 
                    userId: { $eq: userId },
                    type: { $eq: 'user-memory' }
                }
            })
        });

        if (!response.ok) {
            throw new Error(`Semantic search API returned ${response.status}`);
        }

        const data = await response.json();
        
        if (!data.success || !data.matches) {
            throw new Error('Invalid response from semantic search API');
        }

        // ‚úÖ Map Pinecone results to dive log format
        const items = data.matches
            .filter(match => isDiveLogMatch(match))
            .map(match => ({
                _id: match.id,
                userId: match.metadata?.userId || userId,
                discipline: match.metadata?.discipline || '',
                location: match.metadata?.location || '',
                targetDepth: match.metadata?.targetDepth || 0,
                reachedDepth: match.metadata?.reachedDepth || 0,
                timestamp: match.metadata?.timestamp || new Date().toISOString(),
                notes: match.metadata?.notes || '',
                score: match.score,
                searchType: 'semantic'
            }));

        return {
            success: true,
            data: items,
            count: items.length
        };

    } catch (error) {
        console.error("‚ùå Semantic dive search error:", error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * ‚úÖ PERFORM DATABASE SEARCH for dive logs
 */
async function performDiveLogDatabaseSearch(userId, searchQuery, limit, skip, filters, sortBy, sortOrder) {
    try {
        console.log("üóÑÔ∏è Performing dive log database search");

        let query = wixData.query(COLLECTION_ID)
            .eq("userId", userId);

        // ‚úÖ FILTER FOR DIVE LOGS (items with depth data)
        query = query.or(
            wixData.query(COLLECTION_ID).gt("targetDepth", 0),
            wixData.query(COLLECTION_ID).gt("reachedDepth", 0),
            wixData.query(COLLECTION_ID).ne("discipline", "")
        ).eq("userId", userId);

        // ‚úÖ ADD TEXT SEARCH
        if (searchQuery && searchQuery.trim()) {
            query = query.or(
                wixData.query(COLLECTION_ID).contains("discipline", searchQuery),
                wixData.query(COLLECTION_ID).contains("location", searchQuery),
                wixData.query(COLLECTION_ID).contains("notes", searchQuery)
            ).eq("userId", userId);
        }

        // ‚úÖ ADD FILTERS
        if (filters.discipline) {
            query = query.eq("discipline", filters.discipline);
        }
        if (filters.location) {
            query = query.contains("location", filters.location);
        }
        if (filters.minDepth) {
            query = query.ge("reachedDepth", parseFloat(filters.minDepth));
        }
        if (filters.maxDepth) {
            query = query.le("reachedDepth", parseFloat(filters.maxDepth));
        }
        if (filters.dateFrom) {
            query = query.ge("timestamp", new Date(filters.dateFrom));
        }
        if (filters.dateTo) {
            query = query.le("timestamp", new Date(filters.dateTo));
        }

        // ‚úÖ ADD SORTING
        const sortField = sortBy === 'depth' ? 'reachedDepth' : 
                         sortBy === 'discipline' ? 'discipline' : 
                         sortBy === 'location' ? 'location' : 'timestamp';
        
        query = query[sortOrder === 'asc' ? 'ascending' : 'descending'](sortField);

        // ‚úÖ ADD PAGINATION
        query = query.skip(skip).limit(Math.min(limit, MAX_RESULTS));

        const result = await query.find();

        // ‚úÖ GET TOTAL COUNT
        const countQuery = wixData.query(COLLECTION_ID)
            .eq("userId", userId)
            .or(
                wixData.query(COLLECTION_ID).gt("targetDepth", 0),
                wixData.query(COLLECTION_ID).gt("reachedDepth", 0),
                wixData.query(COLLECTION_ID).ne("discipline", "")
            );
        const countResult = await countQuery.count();

        return {
            items: result.items || [],
            totalCount: countResult || result.items?.length || 0
        };

    } catch (error) {
        console.error("‚ùå Database dive search error:", error);
        throw new Error("Database dive search failed: " + error.message);
    }
}

/**
 * ‚úÖ SYNC DIVE LOG TO NEXT.JS BACKEND (for embedding generation)
 */
async function syncDiveLogToBackend(diveLog) {
    try {
        const payload = {
            userId: diveLog.userId,
            memory: {
                content: `Dive Log: ${diveLog.discipline} at ${diveLog.location}`,
                logEntry: diveLog.notes || '',
                diveLog: {
                    discipline: diveLog.discipline,
                    location: diveLog.location,
                    targetDepth: diveLog.targetDepth,
                    reachedDepth: diveLog.reachedDepth,
                    notes: diveLog.notes,
                    date: diveLog.timestamp
                },
                timestamp: diveLog.timestamp
            }
        };

        const response = await fetch(MEMORY_SYNC_API, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            console.log("‚úÖ Dive log synced to backend successfully");
        } else {
            console.warn(`‚ö†Ô∏è Backend sync failed: ${response.status}`);
        }

    } catch (error) {
        console.warn("‚ö†Ô∏è Backend sync error:", error.message);
    }
}

/**
 * ‚úÖ VALIDATE DIVE LOG DATA
 */
function validateDiveLog(diveLog) {
    if (!diveLog.discipline && !diveLog.targetDepth && !diveLog.reachedDepth) {
        return "Dive log must have either discipline or depth information";
    }

    if (diveLog.targetDepth && (diveLog.targetDepth < 0 || diveLog.targetDepth > 300)) {
        return "Target depth must be between 0 and 300 meters";
    }

    if (diveLog.reachedDepth && (diveLog.reachedDepth < 0 || diveLog.reachedDepth > 300)) {
        return "Reached depth must be between 0 and 300 meters";
    }

    return null; // No validation errors
}

/**
 * ‚úÖ CHECK IF ITEM IS A DIVE LOG
 */
function isDiveLog(item) {
    return !!(item.discipline || item.targetDepth > 0 || item.reachedDepth > 0);
}

/**
 * ‚úÖ CHECK IF SEMANTIC SEARCH MATCH IS DIVE LOG
 */
function isDiveLogMatch(match) {
    const meta = match.metadata || {};
    return !!(meta.discipline || meta.targetDepth > 0 || meta.reachedDepth > 0);
}

/**
 * ‚úÖ MAP DIVE LOG FIELDS to database schema with improved parsing
 */
function mapDiveLogFields(diveLog) {
    return {
        date: diveLog.date ? new Date(diveLog.date) : new Date(),
        disciplineType: String(diveLog.disciplineType || ""),
        discipline: String(diveLog.discipline || ""),
        location: String(diveLog.location || ""),
        targetDepth: parseRoughNumber(diveLog.targetDepth),
        reachedDepth: parseRoughNumber(diveLog.reachedDepth),
        notes: String(diveLog.notes || ""),
        // Additional fields
        visibility: String(diveLog.visibility || ""),
        waterTemp: parseRoughNumber(diveLog.waterTemp),
        weight: parseRoughNumber(diveLog.weight),
        surfaceInterval: String(diveLog.surfaceInterval || ""),
        breathHold: String(diveLog.breathHold || "")
    };
}

/**
 * ‚úÖ ENHANCED NUMBER PARSING
 * Handles: "35-40", "35¬±2", "35m", "35.5", etc.
 */
function parseRoughNumber(value) {
    if (!value) return 0;
    if (typeof value === "number") return value;

    const str = String(value).trim().toLowerCase();

    // Remove units (m, meters, ft, feet)
    const cleanStr = str.replace(/[mft]|meters?|feet?/g, '').trim();

    // Handle ranges like "35-40"
    if (cleanStr.includes('-')) {
        const parts = cleanStr.split('-').map(v => parseFloat(v.trim()));
        if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
            return (parts[0] + parts[1]) / 2;
        }
    }

    // Handle "35¬±2" notation
    if (cleanStr.includes('¬±')) {
        const [num] = cleanStr.split('¬±').map(v => parseFloat(v.trim()));
        if (!isNaN(num)) return num;
    }

    // Handle "~35" approximation
    if (cleanStr.startsWith('~')) {
        const num = parseFloat(cleanStr.substring(1));
        if (!isNaN(num)) return num;
    }

    // Standard number parsing
    const num = parseFloat(cleanStr);
    return isNaN(num) ? 0 : num;
}

/**
 * ‚úÖ HELPER: Parse request body safely
 */
async function parseRequestBody(request) {
    try {
        const bodyText = await request.body.text();
        return JSON.parse(bodyText);
    } catch (error) {
        throw new Error('Invalid JSON in request body');
    }
}
