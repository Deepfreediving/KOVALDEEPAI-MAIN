// ===== üìÑ http-userMemory.jsw - FIXED VERSION =====
// Handles CRUD operations for storing and retrieving user memory logs, with optional embedding storage in Pinecone

import wixData from 'wix-data';
import wixUsersBackend from 'wix-users-backend';
import { fetch } from 'wix-fetch'; // ‚úÖ Use wix-fetch instead of node fetch

// ‚úÖ MISSING: You need to create this utility file or use inline responses
// import { 
//     successResponse, 
//     badRequestResponse, 
//     unauthorizedResponse, 
//     serverErrorResponse, 
//     baseResponse 
// } from 'backend/http-utils.jsw';

// ‚úÖ FIXED: OpenAI v4+ compatible import
// Old: import { Configuration, OpenAIApi } from 'openai';
// import OpenAI from 'openai'; // ‚úÖ Correct for OpenAI v4+

// ‚úÖ FIXED: Pinecone client setup
// import { Pinecone } from '@pinecone-database/pinecone';

// === CONFIGURATION ===
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const PINECONE_API_KEY = process.env.PINECONE_API_KEY;
const PINECONE_INDEX_NAME = process.env.PINECONE_INDEX || "koval-ai-memories";

// ‚úÖ Response helpers (inline since http-utils.jsw doesn't exist)
function createResponse(status, data, request) {
    return {
        status,
        body: data,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization'
        }
    };
}

const successResponse = (request, data) => createResponse(200, { success: true, timestamp: new Date().toISOString(), ...data }, request);
const badRequestResponse = (request, message) => createResponse(400, { error: message, success: false, timestamp: new Date().toISOString() }, request);
const unauthorizedResponse = (request, message) => createResponse(401, { error: message, success: false, timestamp: new Date().toISOString() }, request);
const serverErrorResponse = (request, message) => createResponse(500, { error: message, success: false, timestamp: new Date().toISOString() }, request);
const baseResponse = (status, request) => ({ status, headers: createResponse(status, {}, request).headers });

// === Helpers ===
const toNum = v => {
    if (!v) return 0;
    const match = String(v).match(/\\d+(\\.\\d+)?/); // extract first number
    return match ? Number(match[0]) : 0;
};

/**
 * ‚úÖ OPTIONS: Preflight requests
 */
export function options_userMemory(request) {
    return baseResponse(204, request);
}

/**
 * ‚úÖ GET: Retrieve user memories
 */
export async function get_userMemory(request) {
    try {
        // ‚úÖ FIXED: Better user identification
        let userId = request.query?.userId;
        
        // Try to get from current user if available
        try {
            // ‚úÖ FIXED: Correct way to get current user in backend
            if (wixUsersBackend.currentUser && wixUsersBackend.currentUser.loggedIn) {
                userId = wixUsersBackend.currentUser.id;
                console.log("‚úÖ Found authenticated user:", userId);
            }
        } catch (authError) {
            console.log("‚ÑπÔ∏è No authenticated user, using query userId");
        }
        
        if (!userId) {
            return unauthorizedResponse(request, "User not identified.");
        }

        const limit = Math.min(Number(request.query?.limit || 50), 100); // ‚úÖ Cap at 100
        const skip = Math.max(Number(request.query?.skip || 0), 0);

        const result = await wixData.query("@deepfreediving/kovaldeepai-app/Import1")
            .eq("userId", userId)
            .descending("timestamp")
            .skip(skip)
            .limit(limit)
            .find();

        return successResponse(request, {
            success: true,
            count: result.items.length,
            totalCount: result.totalCount || result.items.length,
            data: result.items || []
        });

    } catch (error) {
        console.error("‚ùå GET userMemory error:", error);
        return serverErrorResponse(request, "Failed to retrieve user memories.");
    }
}

/**
 * ‚úÖ POST: Store or update user memories
 */
export async function post_userMemory(request) {
    try {
        // ‚úÖ FIXED: Better user identification
        let userId;
        
        try {
            // ‚úÖ FIXED: Correct way to get current user in backend
            if (wixUsersBackend.currentUser && wixUsersBackend.currentUser.loggedIn) {
                userId = wixUsersBackend.currentUser.id;
                console.log("‚úÖ Found authenticated user for POST:", userId);
            }
        } catch (authError) {
            console.log("‚ÑπÔ∏è No authenticated user");
        }

        // ‚úÖ FIXED: Proper body parsing
        let body;
        try {
            const bodyText = await request.body.text();
            body = JSON.parse(bodyText);
        } catch (parseError) {
            return badRequestResponse(request, "Invalid or empty JSON payload.");
        }

        if (!userId && body.userId) userId = body.userId;
        if (!userId) return unauthorizedResponse(request, "User not identified.");

        const entries = Array.isArray(body) ? body : [body];
        const results = [];

        for (const entry of entries) {
            if (!entry.memoryContent && !entry.diveLog) continue;
            
            try {
                const saved = await upsertUserMemory({ ...entry, userId });
                results.push(saved);

                // ‚úÖ OPTIONAL: Push to external AI backend (non-blocking)
                // Since you're using Next.js backend, consider calling it here
                syncToExternalBackend(saved).catch(err => {
                    console.warn("‚ö†Ô∏è External sync failed:", err.message);
                });

            } catch (saveError) {
                console.error("‚ùå Failed to save entry:", saveError);
                // Continue with other entries
            }
        }

        return successResponse(request, {
            success: true,
            count: results.length,
            data: results
        });

    } catch (error) {
        console.error("‚ùå POST userMemory error:", error);
        return serverErrorResponse(request, "Failed to store user memory data.");
    }
}

/**
 * ‚úÖ Upsert user memory (insert or update if exists)
 */
async function upsertUserMemory(data) {
    const {
        userId,
        logEntry = "",
        memoryContent = "",
        timestamp = new Date(),
        sessionName = "Session",
        sessionId = null,
        metadata = {},
        diveLog = {}
    } = data;

    const ts = new Date(timestamp);
    const uniqueId = diveLog?.id || `${userId}-${sessionName}-${ts.getTime()}`;

    try {
        // ‚úÖ Check for existing record
        const existing = await wixData.query("@deepfreediving/kovaldeepai-app/Import1")
            .eq("userId", userId)
            .eq("uniqueKey", uniqueId)
            .find();

        const item = {
            userId,
            uniqueKey: uniqueId,
            logEntry,
            memoryContent,
            timestamp: ts,
            sessionName,
            sessionId,
            metadata,
            ...mapDiveLogFields(diveLog)
        };

        // ‚úÖ Update or insert
        if (existing.items.length > 0) {
            return await wixData.update("@deepfreediving/kovaldeepai-app/Import1", { 
                _id: existing.items[0]._id, 
                ...item 
            });
        } else {
            return await wixData.insert("@deepfreediving/kovaldeepai-app/Import1", item);
        }
        
    } catch (dbError) {
        console.error("‚ùå Database operation failed:", dbError);
        throw new Error("Failed to save memory data");
    }
}

/**
 * ‚úÖ Map dive log fields to DB-safe values
 */
function mapDiveLogFields(diveLog) {
    return {
        date: diveLog.date ? new Date(diveLog.date) : new Date(),
        disciplineType: String(diveLog.disciplineType || ""),
        discipline: String(diveLog.discipline || ""),
        location: String(diveLog.location || ""),
        targetDepth: toNum(diveLog.targetDepth),
        reachedDepth: toNum(diveLog.reachedDepth),
        notes: String(diveLog.notes || "")
    };
}

/**
 * ‚úÖ FIXED: Sync to your Next.js backend instead of direct Pinecone
 * This is more reliable and uses your existing infrastructure
 */
async function syncToExternalBackend(memoryItem) {
    if (!memoryItem) return;

    try {
        const payload = {
            userId: memoryItem.userId,
            memory: {
                content: memoryItem.memoryContent || "",
                logEntry: memoryItem.logEntry || "",
                diveLog: {
                    discipline: memoryItem.discipline,
                    location: memoryItem.location,
                    targetDepth: memoryItem.targetDepth,
                    reachedDepth: memoryItem.reachedDepth,
                    notes: memoryItem.notes
                },
                timestamp: memoryItem.timestamp
            }
        };

        // ‚úÖ Call your Next.js backend to handle embeddings
        const response = await fetch('https://kovaldeepai-main.vercel.app/api/userMemory/sync', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            console.warn(`‚ö†Ô∏è External sync failed: ${response.status}`);
        }

    } catch (error) {
        console.warn("‚ö†Ô∏è External sync error:", error.message);
        // Don't throw - this is non-critical
    }
}

/**
 * ‚úÖ DELETE: Remove user memory (optional)
 */
export async function delete_userMemory(request) {
    try {
        let userId;
        try {
            // ‚úÖ FIXED: Correct way to get current user in backend
            if (wixUsersBackend.currentUser && wixUsersBackend.currentUser.loggedIn) {
                userId = wixUsersBackend.currentUser.id;
                console.log("‚úÖ Found authenticated user for DELETE:", userId);
            }
        } catch (authError) {
            // No auth required for delete if memoryId provided
        }

        const memoryId = request.query?.memoryId;
        if (!memoryId) {
            return badRequestResponse(request, "Memory ID is required");
        }

        // ‚úÖ Verify ownership before deletion
        const memory = await wixData.get("@deepfreediving/kovaldeepai-app/Import1", memoryId);
        if (!memory) {
            return badRequestResponse(request, "Memory not found");
        }

        if (userId && memory.userId !== userId) {
            return unauthorizedResponse(request, "Not authorized to delete this memory");
        }

        await wixData.remove("@deepfreediving/kovaldeepai-app/Import1", memoryId);

        return successResponse(request, {
            success: true,
            message: "Memory deleted successfully"
        });

    } catch (error) {
        console.error("‚ùå DELETE userMemory error:", error);
        return serverErrorResponse(request, "Failed to delete memory");
    }
}
