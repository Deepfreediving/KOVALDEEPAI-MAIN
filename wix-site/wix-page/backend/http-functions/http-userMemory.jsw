// üî• HTTP-USERMEMORY.JSW - SIMPLIFIED USER MEMORY API
// Version: 5.0.0 - Simplified Edition
// Date: August 14, 2025

import { ok, badRequest, serverError } from 'wix-http-functions';
import wixData from 'wix-data';

// üéØ SIMPLIFIED CONFIGURATION - ALIGNED WITH WIX DATABASE
const MEMORY_CONFIG = {
  COLLECTIONS: {
    DIVE_LOGS: 'DiveLogs'  // Matches Wix database collection name
  },
  
  // DiveLogs collection field mapping (matches Wix database structure)
  FIELDS: {
    USER_ID: 'userId',           // User ID field
    DIVE_LOG_ID: 'diveLogId',    // Dive Log ID field  
    LOG_ENTRY: 'logEntry',       // Log Entry field (JSON string)
    DIVE_DATE: 'diveDate',       // Dive Date field
    DIVE_TIME: 'diveTime',       // Dive Time field
    WATCH_PHOTO: 'watchedPhoto'  // Dive Log Watch Photo field
  },
  
  VERSION: '5.0.0'
};

// üî• CORS Headers
const CORS_HEADERS = {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization'
};

// üî• GET: RETRIEVE USER DIVE LOGS
export async function get_userMemory(request) {
  console.log('üîÑ UserMemory GET request');
  
  try {
    const userId = request.query.userId;
    const includeDetails = request.query.includeDetails === 'true';
    const limit = parseInt(request.query.limit) || 50;
    
    if (!userId) {
      return badRequest({
        headers: CORS_HEADERS,
        body: {
          success: false,
          error: 'userId parameter is required',
          version: MEMORY_CONFIG.VERSION
        }
      });
    }

    console.log(`üìã Looking up data for user: ${userId}`);

    // Get user's dive logs from DiveLogs collection
    const results = await wixData.query(MEMORY_CONFIG.COLLECTIONS.DIVE_LOGS)
      .eq(MEMORY_CONFIG.FIELDS.USER_ID, userId)
      .descending(MEMORY_CONFIG.FIELDS.DIVE_DATE)
      .limit(limit)
      .find();
    
    console.log(`‚úÖ Found ${results.items.length} records`);
    
    // Process the items
    const processedItems = results.items.map(item => {
      let parsedLogEntry = {};
      try {
        parsedLogEntry = JSON.parse(item[MEMORY_CONFIG.FIELDS.LOG_ENTRY] || '{}');
      } catch (e) {
        console.warn('Could not parse logEntry for item:', item._id);
        parsedLogEntry = { error: 'Invalid logEntry format' };
      }

      return {
        _id: item._id,
        userId: item[MEMORY_CONFIG.FIELDS.USER_ID],
        diveLogId: item[MEMORY_CONFIG.FIELDS.DIVE_LOG_ID],
        diveDate: item[MEMORY_CONFIG.FIELDS.DIVE_DATE],
        diveTime: item[MEMORY_CONFIG.FIELDS.DIVE_TIME],
        watchedPhoto: item[MEMORY_CONFIG.FIELDS.WATCH_PHOTO],
        discipline: parsedLogEntry.dive?.discipline || parsedLogEntry.discipline || 'Unknown',
        reachedDepth: parsedLogEntry.dive?.depths?.reached || parsedLogEntry.reachedDepth || 0,
        targetDepth: parsedLogEntry.dive?.depths?.target || parsedLogEntry.targetDepth || 0,
        location: parsedLogEntry.dive?.location || parsedLogEntry.location || 'Unknown',
        notes: parsedLogEntry.dive?.notes || parsedLogEntry.notes || '',
        logEntry: parsedLogEntry,
        _createdDate: item._createdDate
      };
    });

    const responseData = {
      success: true,
      userId: userId,
      totalRecords: processedItems.length,
      timestamp: new Date().toISOString(),
      version: MEMORY_CONFIG.VERSION
    };

    if (includeDetails) {
      responseData.diveLogs = processedItems;
    } else {
      // Return summary info only
      responseData.recentDives = processedItems.slice(0, 5).map(dive => ({
        _id: dive._id,
        diveDate: dive.diveDate,
        discipline: dive.discipline,
        reachedDepth: dive.reachedDepth,
        location: dive.location
      }));
    }

    return ok({
      headers: CORS_HEADERS,
      body: responseData
    });

  } catch (error) {
    console.error('‚ùå GET userMemory error:', error);
    
    return serverError({
      headers: CORS_HEADERS,
      body: {
        success: false,
        error: 'Failed to retrieve user memory',
        details: error.message,
        timestamp: new Date().toISOString(),
        version: MEMORY_CONFIG.VERSION
      }
    });
  }
}

// üî• ENHANCED POST: SAVE COMPRESSED DIVE LOG TO DIVELOGS COLLECTION
export async function post_userMemory(request) {
  console.log('üîÑ UserMemory POST request - saving compressed dive log to DiveLogs collection');
  
  try {
    // Enhanced request parsing and validation
    let requestData;
    try {
      const requestBody = await request.body.text();
      requestData = JSON.parse(requestBody);
      console.log('üìã Parsed request data:', JSON.stringify(requestData, null, 2));
    } catch (error) {
      return badRequest({
        headers: CORS_HEADERS,
        body: {
          success: false,
          error: 'Invalid JSON in request body',
          details: error.message,
          version: MEMORY_CONFIG.VERSION
        }
      });
    }

    const { userId, memoryContent, type = 'chat_memory', diveLogData, sessionName } = requestData;
    
    if (!userId) {
      return badRequest({
        headers: CORS_HEADERS,
        body: {
          success: false,
          error: 'userId is required',
          version: MEMORY_CONFIG.VERSION
        }
      });
    }

    // ‚úÖ COMPRESSED STRUCTURE: Create record using structured format for AI analysis
    let diveLogRecord;
    
    if (diveLogData) {
      // ‚úÖ OPTIMIZED: Create full compressed dive log structure for AI analysis
      const timestamp = new Date().toISOString();
      const diveLogId = `dive_${userId}_${Date.now()}`;
      
      // Parse numeric values
      const targetDepth = parseFloat(diveLogData.targetDepth) || 0;
      const reachedDepth = parseFloat(diveLogData.reachedDepth) || 0;
      const mouthfillDepth = parseFloat(diveLogData.mouthfillDepth) || 0;
      const issueDepth = parseFloat(diveLogData.issueDepth) || 0;
      
      // Calculate analysis fields
      const depthAchievement = targetDepth > 0 ? (reachedDepth / targetDepth) * 100 : 0;
      const progressionScore = Math.max(0, Math.min(100, 
        depthAchievement + 
        (diveLogData.exit === 'Good' ? 10 : 0) + 
        (issueDepth > 0 ? -20 : 0)
      ));
      
      // Identify risk factors
      const riskFactors = [];
      if (diveLogData.squeeze) riskFactors.push('squeeze-reported');
      if (issueDepth > 0) riskFactors.push('depth-issue');
      if (diveLogData.exit !== 'Good') riskFactors.push('difficult-exit');
      if (reachedDepth > targetDepth * 1.1) riskFactors.push('depth-exceeded');
      
      // Extract technical notes
      const technicalNotes = [];
      if (mouthfillDepth > 0) technicalNotes.push(`Mouthfill at ${mouthfillDepth}m`);
      if (diveLogData.issueComment) technicalNotes.push(`Issue: ${diveLogData.issueComment}`);
      if (diveLogData.surfaceProtocol) technicalNotes.push(`Surface: ${diveLogData.surfaceProtocol}`);
      
      // ‚úÖ Create compressed logEntry with complete structure for AI analysis
      const compressedLogEntry = {
        // Core dive data
        id: diveLogId,
        userId: userId,
        timestamp: timestamp,
        
        // Dive details
        dive: {
          date: diveLogData.date || '',
          disciplineType: diveLogData.disciplineType || '',
          discipline: diveLogData.discipline || 'Freedive',
          location: diveLogData.location || 'Unknown',
          depths: {
            target: targetDepth,
            reached: reachedDepth,
            mouthfill: mouthfillDepth,
            issue: issueDepth
          },
          performance: {
            exit: diveLogData.exit || '',
            duration: diveLogData.durationOrDistance || '',
            totalTime: diveLogData.totalDiveTime || '',
            attemptType: diveLogData.attemptType || '',
            surfaceProtocol: diveLogData.surfaceProtocol || ''
          },
          issues: {
            squeeze: Boolean(diveLogData.squeeze),
            issueComment: diveLogData.issueComment || ''
          },
          notes: diveLogData.notes || ''
        },
        
        // AI analysis fields
        analysis: {
          progressionScore: progressionScore,
          riskFactors: riskFactors,
          technicalNotes: technicalNotes.join(' | '),
          depthAchievement: depthAchievement
        },
        
        // Additional metadata
        metadata: {
          source: 'koval-ai-widget',
          version: '2.0',
          type: 'dive_log'
        }
      };
      
      // Create DiveLogs collection record using correct field names
      diveLogRecord = {
        [MEMORY_CONFIG.FIELDS.USER_ID]: userId,
        [MEMORY_CONFIG.FIELDS.DIVE_LOG_ID]: diveLogId,
        [MEMORY_CONFIG.FIELDS.LOG_ENTRY]: JSON.stringify(compressedLogEntry), // Complete compressed structure
        [MEMORY_CONFIG.FIELDS.DIVE_DATE]: diveLogData.date ? new Date(diveLogData.date) : new Date(),
        [MEMORY_CONFIG.FIELDS.DIVE_TIME]: diveLogData.time || new Date().toLocaleTimeString(),
        [MEMORY_CONFIG.FIELDS.WATCH_PHOTO]: diveLogData.photos || diveLogData.watchPhoto || diveLogData.diveLogWatch || null
      };
      
    } else if (memoryContent) {
      // For chat/memory: use compressed logEntry for AI context
      diveLogRecord = {
        [MEMORY_CONFIG.FIELDS.USER_ID]: userId,
        [MEMORY_CONFIG.FIELDS.DIVE_LOG_ID]: `memory_${Date.now()}`,
        [MEMORY_CONFIG.FIELDS.LOG_ENTRY]: JSON.stringify({
          // Compressed memory data for AI analysis
          content: memoryContent,
          type: type,
          sessionName: sessionName || `Memory - ${new Date().toISOString()}`,
          timestamp: new Date().toISOString(),
          metadata: {
            source: 'chat-memory',
            version: '2.0'
          }
        }),
        [MEMORY_CONFIG.FIELDS.DIVE_DATE]: new Date(),
        [MEMORY_CONFIG.FIELDS.DIVE_TIME]: new Date().toLocaleTimeString(),
        [MEMORY_CONFIG.FIELDS.WATCH_PHOTO]: null
      };
    } else {
      return badRequest({
        headers: CORS_HEADERS,
        body: {
          success: false,
          error: 'Either diveLogData or memoryContent is required',
          version: MEMORY_CONFIG.VERSION
        }
      });
    }

    // Save directly to DiveLogs collection
    const result = await wixData.insert(MEMORY_CONFIG.COLLECTIONS.DIVE_LOGS, diveLogRecord);
    console.log(`‚úÖ Compressed structure saved to DiveLogs collection: ${result._id}`);
    
    // Parse the saved logEntry to show what was stored
    let savedStructure = {};
    try {
      savedStructure = JSON.parse(diveLogRecord[MEMORY_CONFIG.FIELDS.LOG_ENTRY]);
    } catch (e) {
      console.warn('Could not parse saved logEntry for logging');
    }

    return ok({
      headers: CORS_HEADERS,
      body: {
        success: true,
        userId: userId,
        _id: result._id,
        diveLogId: diveLogRecord[MEMORY_CONFIG.FIELDS.DIVE_LOG_ID],
        hasPhoto: !!diveLogRecord[MEMORY_CONFIG.FIELDS.WATCH_PHOTO],
        compressedStructure: {
          hasDiveData: !!savedStructure.dive,
          hasAnalysis: !!savedStructure.analysis,
          progressionScore: savedStructure.analysis?.progressionScore,
          riskFactors: savedStructure.analysis?.riskFactors?.length || 0,
          depthAchievement: savedStructure.analysis?.depthAchievement
        },
        logEntry: diveLogRecord[MEMORY_CONFIG.FIELDS.LOG_ENTRY], // Return compressed data for verification
        timestamp: new Date().toISOString(),
        version: MEMORY_CONFIG.VERSION
      }
    });

  } catch (error) {
    console.error('‚ùå POST userMemory error:', error);
    
    return serverError({
      headers: CORS_HEADERS,
      body: {
        success: false,
        error: 'Failed to save dive log',
        details: error.message,
        timestamp: new Date().toISOString(),
        version: MEMORY_CONFIG.VERSION
      }
    });
  }
}

// üî• OPTIONS: CORS PREFLIGHT
export function options_userMemory(request) {
  console.log('üîÑ CORS preflight request');
  
  return ok({
    headers: CORS_HEADERS,
    body: {
      success: true,
      message: 'CORS preflight OK',
      version: MEMORY_CONFIG.VERSION,
      allowedMethods: ['GET', 'POST', 'OPTIONS'],
      timestamp: new Date().toISOString()
    }
  });
}

console.log("ÔøΩ Simplified User Memory API initialized - DiveLogs fields aligned");
