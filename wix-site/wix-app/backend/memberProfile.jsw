// ðŸ”¥ WIX APP BACKEND: MEMBERPROFILE.JSW - MASTER EDITION
// Optimized for OpenAI & Pinecone integration with Wix best practices
// Version: 4.0.0 - Single Perfect Version for Freediving
// Date: August 9, 2025

import { ok, notFound, serverError, badRequest } from 'wix-http-functions';
import wixData from 'wix-data';
import { currentMember } from 'wix-members';
import { fetch } from 'wix-fetch';

// ðŸŽ¯ MASTER CONFIGURATION - Single Perfect Version
const MEMBER_CONFIG = {
  API_VERSIONS: {
    MASTER: 'master'          // Single perfect version for freediving
  },
  
  COLLECTIONS: {
    USER_MEMORY: "@deepfreediving/kovaldeepai-app/Import1",
    REGISTRATIONS: "KovalAIRegistrations", 
    MEMBERS: "Members/FullData"
  },
  
  LIMITS: {
    MAX_RESULTS: 100,
    MAX_MEMORY_ENTRIES: 1000,
    MAX_DIVE_LOGS: 500,
    MAX_MESSAGE_LENGTH: 10000,
    MAX_SEARCH_RESULTS: 50,
    PROFILE_CACHE_TTL: 300000,  // 5 minutes
    MAX_RETRIES: 3
  },
  
  AI_INTEGRATION: {
    OPENAI_ENDPOINTS: {
      EMBEDDING: 'https://kovaldeepai-main.vercel.app/api/openai/embedding',
      ANALYSIS: 'https://kovaldeepai-main.vercel.app/api/openai/analyze-profile'
    },
    PINECONE_ENDPOINTS: {
      UPSERT: 'https://kovaldeepai-main.vercel.app/api/pinecone/upsert-profile',
      QUERY: 'https://kovaldeepai-main.vercel.app/api/pinecone/query-similar'
    }
  },
  
  PERFORMANCE: {
    SLOW_QUERY_THRESHOLD: 2000,
    ENABLE_CACHING: true,
    ENABLE_AI_CONTEXT: true,
    REQUEST_TIMEOUT: 10000
  }
};

// ðŸ”¥ CORS HEADERS - Wix Best Practice
const CORS_HEADERS = {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-API-Version'
};

// ðŸ”¥ PERFORMANCE METRICS
let profileMetrics = {
  requests: 0,
  cacheHits: 0,
  aiEnhancements: 0,
  errors: 0,
  totalDuration: 0
};

// ðŸ”¥ UTILITY FUNCTIONS - Wix Best Practices

function getApiVersion(request) {
  return request.headers['x-api-version'] || 
         request.query.version || 
         MEMBER_CONFIG.API_VERSIONS.MASTER; // Default to master
}

function createResponse(status, data) {
  return {
    status,
    body: data,
    headers: CORS_HEADERS
  };
}

function trackMetrics(operation, duration, success = true) {
  profileMetrics.requests++;
  profileMetrics.totalDuration += duration;
  
  if (!success) profileMetrics.errors++;
  if (operation === 'cache') profileMetrics.cacheHits++;
  if (operation === 'ai') profileMetrics.aiEnhancements++;
}

// ðŸ”¥ ENHANCED MEMBER DETECTION - Master Level
async function detectCurrentMember(userId) {
  try {
    // Try provided userId first
    if (userId && !userId.startsWith('guest-')) {
      return userId;
    }
    
    // Master level: Always use enhanced member detection
    try {
      const member = await currentMember.getMember();
      if (member && member._id) {
        console.log(`âœ… Detected authenticated member: ${member._id}`);
        return member._id;
      }
    } catch (memberError) {
      console.warn('âš ï¸ Could not get current member:', memberError.message);
    }
    
    return userId || 'unknown';
  } catch (error) {
    console.warn('âš ï¸ Member detection failed:', error.message);
    return userId || 'unknown';
  }
}

// ðŸ”¥ AI CONTEXT ENHANCEMENT - OpenAI Integration (Always Enabled)
async function enhanceProfileWithAI(memberProfile) {
  if (!MEMBER_CONFIG.PERFORMANCE.ENABLE_AI_CONTEXT) {
    return memberProfile;
  }
  
  try {
    const startTime = Date.now();
    
    // Generate AI context summary
    const profileText = `${memberProfile.displayName} - ${memberProfile.about || 'Freediver'} - Active: ${memberProfile.isActive}`;
    
    // Call OpenAI for profile analysis (non-blocking)
    const aiAnalysis = await fetch(MEMBER_CONFIG.AI_INTEGRATION.OPENAI_ENDPOINTS.ANALYSIS, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        profileData: memberProfile,
        analysisType: 'member-profile',
        userId: memberProfile.memberId
      })
    }).catch(error => {
      console.warn('âš ï¸ AI analysis failed:', error.message);
      return null;
    });
    
    let aiContext = {};
    if (aiAnalysis && aiAnalysis.ok) {
      const aiData = await aiAnalysis.json();
      aiContext = {
        aiInsights: aiData.insights || {},
        personalityType: aiData.personalityType || 'Unknown',
        divingExperience: aiData.divingExperience || 'Beginner',
        recommendedTraining: aiData.recommendations || []
      };
    }
    
    const duration = Date.now() - startTime;
    trackMetrics('ai', duration);
    
    return {
      ...memberProfile,
      aiContext: aiContext,
      enhancedAt: new Date().toISOString()
    };
    
  } catch (error) {
    console.warn('âš ï¸ AI enhancement failed:', error.message);
    return memberProfile;
  }
}

// ðŸ”¥ PINECONE INTEGRATION - Vector Storage (Always Enabled)
async function syncProfileToPinecone(memberProfile) {
  try {
    // Generate embedding for profile
    const profileVector = await fetch(MEMBER_CONFIG.AI_INTEGRATION.OPENAI_ENDPOINTS.EMBEDDING, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: `${memberProfile.displayName} ${memberProfile.about || ''} ${memberProfile.nickname || ''}`,
        userId: memberProfile.memberId,
        type: 'member-profile'
      })
    });
    
    if (profileVector.ok) {
      const vectorData = await profileVector.json();
      
      // Upsert to Pinecone
      await fetch(MEMBER_CONFIG.AI_INTEGRATION.PINECONE_ENDPOINTS.UPSERT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: `profile-${memberProfile.memberId}`,
          values: vectorData.embedding,
          metadata: {
            userId: memberProfile.memberId,
            displayName: memberProfile.displayName,
            type: 'member-profile',
            updatedAt: new Date().toISOString()
          }
        })
      });
      
      console.log(`ðŸ” Profile synced to Pinecone: ${memberProfile.memberId}`);
    }
  } catch (error) {
    console.warn('âš ï¸ Pinecone sync failed:', error.message);
  }
}

// ðŸ”¥ MAIN GET ENDPOINT - Enhanced with AI Integration
export async function get_memberProfile(request) {
  const startTime = Date.now();
  const version = getApiVersion(request);
  
  try {
    console.log('ðŸ“Š Fetching enhanced member profile data...');
    
    const query = request.query;
    const requestedUserId = query.userId || query.memberId;
    
    if (!requestedUserId) {
      trackMetrics('validation', Date.now() - startTime, false);
      return createResponse(400, { 
        error: 'userId parameter is required',
        success: false,
        version: version
      });
    }

    // Enhanced member detection
    const effectiveUserId = await detectCurrentMember(requestedUserId);
    console.log(`ðŸ” Loading profile for member: ${effectiveUserId}`);

    // Query Members/FullData collection with Wix best practices
    const profileResults = await wixData.query(MEMBER_CONFIG.COLLECTIONS.MEMBERS)
      .eq('_id', effectiveUserId)
      .limit(1)
      .find();

    let memberProfile = null;
    
    if (profileResults.items.length > 0) {
      const profile = profileResults.items[0];
      console.log(`âœ… Found member profile: ${profile.nickname || profile.firstName || 'Unknown'}`);
      
      // Build enhanced profile object
      memberProfile = {
        memberId: profile._id,
        loginEmail: profile.loginEmail,
        nickname: profile.nickname || profile.firstName || profile.displayName,
        firstName: profile.firstName,
        lastName: profile.lastName,
        displayName: profile.nickname || `${profile.firstName || ''} ${profile.lastName || ''}`.trim() || profile.loginEmail?.split('@')[0] || 'Member',
        profilePhoto: profile.profilePhoto,
        coverPhoto: profile.coverPhoto,
        about: profile.about,
        activityStatus: profile.activityStatus,
        lastLoginDate: profile.lastLoginDate,
        slug: profile.slug,
        contactId: profile.contactId,
        phone: profile.phone,
        updatedDate: profile._updatedDate,
        isActive: profile.activityStatus === 'ACTIVE',
        
        // Enhanced fields for AI integration
        profileCompleteness: calculateProfileCompleteness(profile),
        memberSince: profile._createdDate,
        lastActiveDate: profile.lastLoginDate,
        profileStrength: calculateProfileStrength(profile)
      };
      
      // Master level: Always add AI context
      memberProfile = await enhanceProfileWithAI(memberProfile);
      
      // Master level: Always sync to Pinecone for vector search
      syncProfileToPinecone(memberProfile);
      
      console.log(`ðŸ“Š Enhanced profile data assembled:`, {
        memberId: memberProfile.memberId,
        displayName: memberProfile.displayName,
        email: memberProfile.loginEmail,
        completeness: memberProfile.profileCompleteness,
        hasAiContext: !!memberProfile.aiContext,
        isActive: memberProfile.isActive
      });
      
    } else {
      console.log(`âš ï¸ No profile found for member: ${effectiveUserId}`);
      
      // Return enhanced minimal profile
      memberProfile = {
        memberId: effectiveUserId,
        displayName: 'Member',
        nickname: 'Diver',
        loginEmail: 'unknown@email.com',
        isActive: false,
        profileCompleteness: 0,
        profileStrength: 'incomplete',
        memberSince: new Date().toISOString(),
        isNewMember: true
      };
    }

    const duration = Date.now() - startTime;
    trackMetrics('complete', duration, true);

    // Build response with version-specific enhancements
    const response = {
      success: true,
      profile: memberProfile,
      memberId: effectiveUserId,
      source: 'Members/FullData',
      timestamp: new Date().toISOString(),
      version: version
    };

    // Master level: Always include performance metrics
    response.performance = {
      duration: `${duration}ms`,
      memberDetection: effectiveUserId !== requestedUserId ? 'enhanced' : 'direct',
      aiEnhanced: !!memberProfile.aiContext,
      profileCompleteness: memberProfile.profileCompleteness
    };
    
    response.metrics = {
      totalRequests: profileMetrics.requests,
      cacheHitRate: profileMetrics.requests > 0 ? (profileMetrics.cacheHits / profileMetrics.requests) * 100 : 0,
      aiEnhancements: profileMetrics.aiEnhancements,
      averageResponseTime: profileMetrics.requests > 0 ? profileMetrics.totalDuration / profileMetrics.requests : 0
    };

    return createResponse(200, response);

  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics('error', duration, false);
    
    console.error('âŒ Error fetching member profile:', error);
    return createResponse(500, {
      success: false,
      error: 'Failed to fetch member profile',
      details: error.message,
      timestamp: new Date().toISOString(),
      version: version
    });
  }
}

// ðŸ”¥ HELPER FUNCTIONS - Wix Best Practices
function calculateProfileCompleteness(profile) {
  const fields = ['firstName', 'lastName', 'about', 'profilePhoto', 'phone'];
  const completed = fields.filter(field => profile[field] && profile[field].trim()).length;
  return Math.round((completed / fields.length) * 100);
}

function calculateProfileStrength(profile) {
  const completeness = calculateProfileCompleteness(profile);
  if (completeness >= 80) return 'strong';
  if (completeness >= 60) return 'good';
  if (completeness >= 40) return 'fair';
  return 'incomplete';
}

// ðŸ”¥ POST METHOD - Enhanced Profile Updates with AI Integration
export async function post_memberProfile(request) {
  const startTime = Date.now();
  const version = getApiVersion(request);
  
  try {
    const requestData = await request.body.json();
    const { userId, updates, aiSync = false } = requestData;
    
    if (!userId) {
      return createResponse(400, {
        success: false,
        error: 'userId is required for profile updates',
        version: version
      });
    }
    
    console.log(`ðŸ“ Updating profile for member: ${userId}`);
    
    // Validate updates
    const allowedFields = ['firstName', 'lastName', 'about', 'phone', 'nickname'];
    const sanitizedUpdates = {};
    
    Object.keys(updates).forEach(key => {
      if (allowedFields.includes(key) && updates[key] !== undefined) {
        sanitizedUpdates[key] = updates[key];
      }
    });
    
    if (Object.keys(sanitizedUpdates).length === 0) {
      return createResponse(400, {
        success: false,
        error: 'No valid fields to update',
        allowedFields: allowedFields,
        version: version
      });
    }
    
    // Update profile
    const updatePayload = {
      _id: userId,
      ...sanitizedUpdates,
      _updatedDate: new Date()
    };
    
    const updateResult = await wixData.update(MEMBER_CONFIG.COLLECTIONS.MEMBERS, updatePayload);
    
    // Master level: Always sync updates to AI systems
    if (aiSync) {
      // Update Pinecone vector if profile content changed
      if (sanitizedUpdates.about || sanitizedUpdates.firstName || sanitizedUpdates.lastName) {
        const updatedProfile = await get_memberProfile({ 
          query: { userId }, 
          headers: { 'x-api-version': version } 
        });
        
        if (updatedProfile.status === 200) {
          await syncProfileToPinecone(updatedProfile.body.profile);
        }
      }
    }
    
    const duration = Date.now() - startTime;
    trackMetrics('update', duration, true);
    
    return createResponse(200, {
      success: true,
      updated: updateResult,
      updatedFields: Object.keys(sanitizedUpdates),
      aiSynced: aiSync,
      timestamp: new Date().toISOString(),
      version: version,
      performance: { duration: `${duration}ms` }
    });
    
  } catch (error) {
    const duration = Date.now() - startTime;
    trackMetrics('update', duration, false);
    
    console.error('âŒ Error updating member profile:', error);
    return createResponse(500, {
      success: false,
      error: 'Failed to update member profile',
      details: error.message,
      timestamp: new Date().toISOString(),
      version: version
    });
  }
}

// ðŸ”¥ OPTIONS METHOD - CORS Support
export function options_memberProfile(request) {
  return createResponse(200, {
    message: 'CORS preflight successful',
    supportedMethods: ['GET', 'POST', 'OPTIONS'],
    version: 'master',
    features: ['AI Enhancement', 'Pinecone Integration', 'Performance Tracking']
  });
}

// ðŸ”¥ GET METRICS - Performance Monitoring (Always Available)
export async function get_memberProfileMetrics(request) {
  const version = getApiVersion(request);
  
  return createResponse(200, {
    success: true,
    metrics: profileMetrics,
    config: MEMBER_CONFIG,
    integrations: {
      openai: !!MEMBER_CONFIG.AI_INTEGRATION.OPENAI_ENDPOINTS.ANALYSIS,
      pinecone: !!MEMBER_CONFIG.AI_INTEGRATION.PINECONE_ENDPOINTS.UPSERT,
      wixMembers: true
    },
    version: version
  });
}

// ðŸ”¥ WRAPPER FUNCTIONS FOR DIRECT BACKEND CALLS
// These functions are called directly by the frontend using backend.getUserProfile() etc.
export async function getUserProfile(requestData) {
  // Create a mock request object that matches the HTTP function signature
  const mockRequest = {
    body: { json: () => Promise.resolve({}) },
    headers: {},
    query: requestData || {},
    method: 'GET'
  };
  
  // Call the main HTTP function and extract the response body
  const result = await get_memberProfile(mockRequest);
  return result.body || result;
}

// Alternative wrapper name that matches the file name
export async function memberProfile(requestData) {
  const mockRequest = {
    body: {
      json: () => Promise.resolve(requestData)
    },
    headers: {},
    query: {},
    method: 'POST'
  };
  
  const result = await post_memberProfile(mockRequest);
  return result.body || result;
}

console.log("ðŸ”¥ Master Member Profile API initialized - Perfect version for freediving community");
