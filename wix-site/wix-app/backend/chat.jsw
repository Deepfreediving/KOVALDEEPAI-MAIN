// WIX APP BACKEND: CHAT.JSW - OPTIMIZED FOR @deepfreediving/kovaldeepai-app
// Chat API endpoint for Wix App environment
// Version: 4.x - Dynamic versioning for production releases

import { ok, badRequest, serverError } from 'wix-http-functions';
import { fetch } from 'wix-fetch';
import { authentication } from 'wix-members-backend';

// üéØ MASTER CHAT CONFIGURATION
const CHAT_CONFIG = {
  APP_ID: '@deepfreediving/kovaldeepai-app',
  VERSION: '4.x',
  API_ENDPOINTS: {
    AI_BACKEND: 'https://kovaldeepai-main.vercel.app/api/openai/chat',
    FALLBACK_BACKEND: 'https://kovaldeepai-main.vercel.app/api/chat'
  },
  
  VALIDATION: {
    MAX_MESSAGE_LENGTH: 5000,
    MIN_MESSAGE_LENGTH: 1
  },
  
  PERFORMANCE: {
    REQUEST_TIMEOUT: 15000,
    RETRY_ATTEMPTS: 2
  },
  
  CORS_HEADERS: {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'X-Wix-App-ID': '@deepfreediving/kovaldeepai-app'
  }
};

// üî• MAIN CHAT ENDPOINT
export async function post_chat(request) {
  const startTime = Date.now();
  
  try {
    // Parse request body (improved error handling)
    let requestData;
    try {
      // First get the raw body text, then parse JSON
      const requestBody = await request.body.text();
      console.log('üì• Received request body:', requestBody ? 'Present' : 'Empty');
      
      if (!requestBody || requestBody.trim() === '') {
        return badRequest({
          error: 'Empty request body',
          headers: CHAT_CONFIG.CORS_HEADERS
        });
      }
      
      requestData = JSON.parse(requestBody);
      console.log('‚úÖ Request data parsed successfully');
    } catch (error) {
      console.error('‚ùå JSON parsing error:', error.message);
      return badRequest({
        error: 'Invalid JSON in request body',
        details: error.message,
        headers: CHAT_CONFIG.CORS_HEADERS
      });
    }

    // Validate message
    const { message, userMessage, userId, sessionId } = requestData;
    
    // Support both 'message' and 'userMessage' parameter names
    const actualMessage = message || userMessage;
    
    if (!actualMessage || typeof actualMessage !== 'string') {
      return badRequest({
        error: 'Message is required and must be a string (use "message" or "userMessage" parameter)',
        headers: CHAT_CONFIG.CORS_HEADERS
      });
    }

    if (actualMessage.length < CHAT_CONFIG.VALIDATION.MIN_MESSAGE_LENGTH) {
      return badRequest({
        error: 'Message too short',
        headers: CHAT_CONFIG.CORS_HEADERS
      });
    }

    if (actualMessage.length > CHAT_CONFIG.VALIDATION.MAX_MESSAGE_LENGTH) {
      return badRequest({
        error: 'Message too long',
        headers: CHAT_CONFIG.CORS_HEADERS
      });
    }

    // Get current member if available
    let member = null;
    try {
      member = await authentication.getCurrentMember();
    } catch (error) {
      console.log('No authenticated member available');
    }

    // Prepare request for AI backend
    const aiRequest = {
      message: actualMessage.trim(),
      userId: userId || (member ? member._id : 'anonymous'),
      sessionId: sessionId || 'wix-app-session',
      source: 'wix-app',
      timestamp: new Date().toISOString()
    };

    // Call AI backend
    const aiResponse = await fetch(CHAT_CONFIG.API_ENDPOINTS.AI_BACKEND, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(aiRequest)
    });

    if (!aiResponse.ok) {
      console.error(`AI backend error: ${aiResponse.status}`);
      throw new Error(`AI backend returned ${aiResponse.status}`);
    }

    const aiData = await aiResponse.json();
    
    const duration = Date.now() - startTime;
    console.log(`Chat request completed in ${duration}ms`);

    return ok({
      ...aiData,
      metadata: {
        processingTime: duration,
        source: 'wix-app-backend',
        timestamp: new Date().toISOString()
      }
    }, CHAT_CONFIG.CORS_HEADERS);

  } catch (error) {
    console.error('‚ùå Chat endpoint error:', error);
    
    // More detailed error response based on error type
    const errorResponse = {
      error: 'Chat service temporarily unavailable',
      details: error.message,
      timestamp: new Date().toISOString(),
      source: 'wix-app-backend'
    };
    
    // Add specific error context if available
    if (error.code) {
      errorResponse.errorCode = error.code;
    }
    
    if (error.response?.status) {
      errorResponse.upstreamStatus = error.response.status;
    }
    
    return serverError(errorResponse, CHAT_CONFIG.CORS_HEADERS);
  }
}

// üî• OPTIONS HANDLER (CORS)
export function options_chat(request) {
  return ok({
    message: 'CORS preflight OK'
  }, CHAT_CONFIG.CORS_HEADERS);
}

// üî• GET HANDLER (Status Check)
export function get_chat(request) {
  return ok({
    status: 'operational',
    service: 'wix-app-chat',
    timestamp: new Date().toISOString(),
    endpoints: ['POST /chat', 'OPTIONS /chat'],
    version: '4.0.0'
  }, CHAT_CONFIG.CORS_HEADERS);
}

// üî• WRAPPER FUNCTION FOR DIRECT BACKEND CALLS
// This function is called directly by the frontend using backend.chat()
export async function chat(requestData) {
  console.log('üîÑ Chat wrapper called with:', JSON.stringify(requestData, null, 2));
  
  try {
    // Validate input data
    if (!requestData || typeof requestData !== 'object') {
      throw new Error('Invalid request data - must be an object');
    }
    
    // Create a mock request object that matches the HTTP function signature
    const mockRequest = {
      body: {
        text: () => Promise.resolve(JSON.stringify(requestData)),
        json: () => Promise.resolve(requestData)
      },
      headers: {},
      query: {}
    };
    
    // Call the main HTTP function and extract the response body
    const result = await post_chat(mockRequest);
    console.log('‚úÖ Chat wrapper successful, result status:', result.status || 'unknown');
    
    return result.body || result;
  } catch (error) {
    console.error('‚ùå Chat wrapper error:', error);
    
    // Return a structured error response instead of throwing
    return {
      error: 'Chat wrapper failed',
      details: error.message,
      timestamp: new Date().toISOString(),
      success: false
    };
  }
}
