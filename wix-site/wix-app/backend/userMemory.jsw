// üî• WIX APP BACKEND: HTTP-USERMEMORY.JSW - OPTIMIZED FOR @deepfreediving/kovaldeepai-app
// Deploy this to Wix App Backend: backend/http-functions/userMemory.js
// Version: 4.x - Updated for Wix App Integration (Auto-versioning for 4.0 release)

import { ok, badRequest, serverError } from 'wix-http-functions';
import wixData from 'wix-data';
import { authentication } from 'wix-members-backend';

// üéØ ENHANCED CONFIGURATION FOR WIX APP
const MEMORY_CONFIG = {
  COLLECTION_NAME: 'UserMemory', // Your Wix app collection
  APP_ID: '@deepfreediving/kovaldeepai-app',
  VERSION: '4.x',
  
  CORS_HEADERS: {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Wix-App-ID',
    'X-Wix-App-ID': '@deepfreediving/kovaldeepai-app'
  }
};

// üî• ENHANCED GET: RETRIEVE USER MEMORY AND DIVE LOGS
export async function get_userMemory(request) {
  console.log('üîÑ UserMemory GET request received for Wix App:', MEMORY_CONFIG.APP_ID);
  
  try {
    // Enhanced request validation
    const userId = request.query.userId;
    const includeDetails = request.query.includeDetails === 'true';
    const appId = request.headers['X-Wix-App-ID'] || request.headers['x-wix-app-id'];
    
    console.log(`üìã App ID from request: ${appId}`);
    console.log(`üìã Expected App ID: ${MEMORY_CONFIG.APP_ID}`);
    
    if (!userId) {
      return badRequest({
        error: 'userId parameter is required',
        appId: MEMORY_CONFIG.APP_ID,
        version: MEMORY_CONFIG.VERSION
      }, MEMORY_CONFIG.CORS_HEADERS);
    }

    console.log(`üìã Looking up memory for user: ${userId}`);

    // Enhanced query with error handling
    try {
      const results = await wixData.query(MEMORY_CONFIG.COLLECTION_NAME)
        .eq('userId', userId)
        .limit(1)
        .find();
      
      if (results.items && results.items.length > 0) {
        const userMemoryRecord = results.items[0];
        console.log(`‚úÖ Found user memory record with ${userMemoryRecord.diveLogsCount || 0} dive logs`);
        
        const responseData = {
          success: true,
          userId: userId,
          diveLogsCount: userMemoryRecord.diveLogsCount || 0,
          memoriesCount: userMemoryRecord.memoriesCount || 0,
          lastDiveLogDate: userMemoryRecord.lastDiveLogDate || null,
          _id: userMemoryRecord._id,
          appId: MEMORY_CONFIG.APP_ID,
          version: MEMORY_CONFIG.VERSION,
          timestamp: new Date().toISOString()
        };

        if (includeDetails) {
          responseData.diveLogs = userMemoryRecord.diveLogs || [];
          responseData.memories = userMemoryRecord.memories || [];
          responseData.metadata = userMemoryRecord.metadata || {};
        }

        return ok(responseData, MEMORY_CONFIG.CORS_HEADERS);
        
      } else {
        console.log(`üìã No memory record found for user ${userId} - returning empty state`);
        
        return ok({
          success: true,
          userId: userId,
          diveLogsCount: 0,
          memoriesCount: 0,
          diveLogs: [],
          memories: [],
          lastDiveLogDate: null,
          _id: null,
          appId: MEMORY_CONFIG.APP_ID,
          version: MEMORY_CONFIG.VERSION,
          message: 'No records found for this user - ready for first entry'
        }, MEMORY_CONFIG.CORS_HEADERS);
      }
      
    } catch (wixDataError) {
      console.error('‚ùå WixData query error:', wixDataError);
      
      return ok({
        success: false,
        userId: userId,
        diveLogsCount: 0,
        memoriesCount: 0,
        diveLogs: [],
        memories: [],
        error: 'WixData query failed - collection may need setup',
        errorDetails: wixDataError.message,
        appId: MEMORY_CONFIG.APP_ID,
        troubleshooting: 'Check if UserMemory collection exists and has proper permissions'
      }, MEMORY_CONFIG.CORS_HEADERS);
    }

  } catch (error) {
    console.error('‚ùå GET userMemory error:', error);
    
    return serverError({
      error: 'Failed to retrieve user memory',
      details: error.message,
      timestamp: new Date().toISOString(),
      appId: MEMORY_CONFIG.APP_ID,
      version: MEMORY_CONFIG.VERSION
    }, MEMORY_CONFIG.CORS_HEADERS);
  }
}

// üî• ENHANCED POST: SAVE DIVE LOG TO USER MEMORY
export async function post_userMemory(request) {
  console.log('üîÑ UserMemory POST request received for Wix App:', MEMORY_CONFIG.APP_ID);
  
  try {
    // Enhanced request parsing and validation
    let requestData;
    try {
      const requestBody = await request.body.text();
      requestData = JSON.parse(requestBody);
      console.log('üìã Parsed request data:', JSON.stringify(requestData, null, 2));
    } catch (error) {
      return badRequest({
        error: 'Invalid JSON in request body',
        details: error.message,
        appId: MEMORY_CONFIG.APP_ID
      }, MEMORY_CONFIG.CORS_HEADERS);
    }

    const { userId, diveLogData } = requestData;
    
    if (!userId || !diveLogData) {
      return badRequest({
        error: 'userId and diveLogData are required',
        received: { userId: !!userId, diveLogData: !!diveLogData },
        appId: MEMORY_CONFIG.APP_ID
      }, MEMORY_CONFIG.CORS_HEADERS);
    }

    console.log(`üìã Saving dive log for user: ${userId}`);

    // Enhanced dive log entry with metadata
    const diveLogEntry = {
      id: `dive_${Date.now()}`,
      timestamp: new Date().toISOString(),
      ...diveLogData,
      source: 'koval-ai-wix-app',
      appId: MEMORY_CONFIG.APP_ID,
      version: MEMORY_CONFIG.VERSION
    };

    // Get existing record or create new one using enhanced wixData query
    let userMemoryRecord = null;
    try {
      const results = await wixData.query(MEMORY_CONFIG.COLLECTION_NAME)
        .eq('userId', userId)
        .limit(1)
        .find();
      
      if (results.items && results.items.length > 0) {
        userMemoryRecord = results.items[0];
        console.log(`üìã Found existing record for user ${userId} with ${userMemoryRecord.diveLogsCount || 0} dive logs`);
      }
    } catch (error) {
      console.log('üìã No existing record found, will create new one');
    }

    if (userMemoryRecord) {
      // Update existing record with enhanced data
      const existingDiveLogs = userMemoryRecord.diveLogs || [];
      const updatedDiveLogs = [diveLogEntry, ...existingDiveLogs];
      
      const updateData = {
        ...userMemoryRecord,
        diveLogs: updatedDiveLogs,
        diveLogsCount: updatedDiveLogs.length,
        lastDiveLogDate: diveLogEntry.date,
        lastUpdated: new Date().toISOString(),
        appVersion: MEMORY_CONFIG.VERSION,
        _updatedDate: new Date()
      };

      const result = await wixData.update(MEMORY_CONFIG.COLLECTION_NAME, updateData);
      
      console.log(`‚úÖ Updated user memory with dive log. Total: ${updatedDiveLogs.length}`);
      
      return ok({
        success: true,
        operation: 'update',
        diveLogsCount: updatedDiveLogs.length,
        diveLogId: diveLogEntry.id,
        _id: result._id,
        appId: MEMORY_CONFIG.APP_ID,
        timestamp: new Date().toISOString()
      }, MEMORY_CONFIG.CORS_HEADERS);
      
    } else {
      // Create new record with enhanced structure
      const newRecord = {
        userId: userId,
        diveLogs: [diveLogEntry],
        diveLogsCount: 1,
        memories: [],
        memoriesCount: 0,
        lastDiveLogDate: diveLogEntry.date,
        createdAt: new Date().toISOString(),
        lastUpdated: new Date().toISOString(),
        appVersion: MEMORY_CONFIG.VERSION,
        metadata: {
          source: 'koval-ai-wix-app',
          appId: MEMORY_CONFIG.APP_ID,
          firstEntry: diveLogEntry.timestamp
        },
        _createdDate: new Date(),
        _updatedDate: new Date()
      };
      
      const result = await wixData.save(MEMORY_CONFIG.COLLECTION_NAME, newRecord);
      
      console.log(`‚úÖ Created new user memory record with first dive log`);
      
      return ok({
        success: true,
        operation: 'create',
        diveLogsCount: 1,
        diveLogId: diveLogEntry.id,
        _id: result._id,
        appId: MEMORY_CONFIG.APP_ID,
        message: 'First dive log entry created successfully',
        timestamp: new Date().toISOString()
      }, MEMORY_CONFIG.CORS_HEADERS);
    }

  } catch (error) {
    console.error('‚ùå POST userMemory error:', error);
    
    return serverError({
      error: 'Failed to save dive log',
      details: error.message,
      timestamp: new Date().toISOString(),
      appId: MEMORY_CONFIG.APP_ID,
      version: MEMORY_CONFIG.VERSION
    }, MEMORY_CONFIG.CORS_HEADERS);
  }
}

// üî• ENHANCED OPTIONS: CORS PREFLIGHT WITH APP VALIDATION
export function options_userMemory(request) {
  console.log('üîÑ CORS preflight request for Wix App:', MEMORY_CONFIG.APP_ID);
  
  return ok({
    message: 'CORS preflight OK',
    appId: MEMORY_CONFIG.APP_ID,
    version: MEMORY_CONFIG.VERSION,
    allowedMethods: ['GET', 'POST', 'OPTIONS'],
    timestamp: new Date().toISOString()
  }, MEMORY_CONFIG.CORS_HEADERS);
}

// üî• ENHANCED WRAPPER FUNCTIONS FOR DIRECT BACKEND CALLS
// These functions are called directly by the frontend using backend.saveUserMemory() etc.
// Updated for Wix App integration with proper validation and error handling

export async function saveUserMemory(requestData) {
  console.log('üîÑ SaveUserMemory wrapper called for app:', MEMORY_CONFIG.APP_ID);
  console.log('üìã Request data:', JSON.stringify(requestData, null, 2));
  
  try {
    // Enhanced input validation
    if (!requestData || typeof requestData !== 'object') {
      throw new Error('Invalid request data - must be an object');
    }
    
    if (!requestData.userId || !requestData.diveLogData) {
      throw new Error('Missing required fields: userId and diveLogData');
    }
    
    // Create a mock request object that matches the HTTP function signature
    const mockRequest = {
      body: {
        text: () => Promise.resolve(JSON.stringify(requestData)),
        json: () => Promise.resolve(requestData)
      },
      headers: {
        'X-Wix-App-ID': MEMORY_CONFIG.APP_ID,
        'Content-Type': 'application/json'
      },
      query: {},
      method: 'POST'
    };
    
    // Call the main HTTP function and extract the response body
    const result = await post_userMemory(mockRequest);
    console.log('‚úÖ SaveUserMemory wrapper successful, result status:', result.status || 'unknown');
    
    return result.body || result;
  } catch (error) {
    console.error('‚ùå SaveUserMemory wrapper error:', error);
    
    // Return a structured error response instead of throwing
    return {
      error: 'SaveUserMemory wrapper failed',
      details: error.message,
      timestamp: new Date().toISOString(),
      appId: MEMORY_CONFIG.APP_ID,
      success: false
    };
  }
}

// Enhanced wrapper for GET operations
export async function getUserMemory(requestData) {
  console.log('üîÑ GetUserMemory wrapper called for app:', MEMORY_CONFIG.APP_ID);
  console.log('üìã Request data:', JSON.stringify(requestData, null, 2));
  
  try {
    // Enhanced input validation
    if (requestData && typeof requestData !== 'object') {
      throw new Error('Invalid request data - must be an object or null');
    }
    
    const mockRequest = {
      body: { 
        text: () => Promise.resolve('{}'),
        json: () => Promise.resolve({}) 
      },
      headers: {
        'X-Wix-App-ID': MEMORY_CONFIG.APP_ID,
        'Content-Type': 'application/json'
      },
      query: requestData || {},
      method: 'GET'
    };
    
    const result = await get_userMemory(mockRequest);
    console.log('‚úÖ GetUserMemory wrapper successful, result status:', result.status || 'unknown');
    
    return result.body || result;
  } catch (error) {
    console.error('‚ùå GetUserMemory wrapper error:', error);
    
    // Return a structured error response instead of throwing
    return {
      error: 'GetUserMemory wrapper failed',
      details: error.message,
      timestamp: new Date().toISOString(),
      appId: MEMORY_CONFIG.APP_ID,
      success: false
    };
  }
}

// üî• NEW: App Status Check Function
export async function getAppStatus() {
  console.log('üîÑ App status check for:', MEMORY_CONFIG.APP_ID);
  
  try {
    // Test collection access
    const testQuery = await wixData.query(MEMORY_CONFIG.COLLECTION_NAME)
      .limit(1)
      .find();
    
    return {
      success: true,
      appId: MEMORY_CONFIG.APP_ID,
      version: MEMORY_CONFIG.VERSION,
      collection: MEMORY_CONFIG.COLLECTION_NAME,
      collectionAccessible: true,
      totalRecords: testQuery.totalCount || 0,
      timestamp: new Date().toISOString(),
      status: 'operational'
    };
    
  } catch (error) {
    console.error('‚ùå App status check failed:', error);
    
    return {
      success: false,
      appId: MEMORY_CONFIG.APP_ID,
      version: MEMORY_CONFIG.VERSION,
      collection: MEMORY_CONFIG.COLLECTION_NAME,
      collectionAccessible: false,
      error: error.message,
      timestamp: new Date().toISOString(),
      status: 'error'
    };
  }
}
